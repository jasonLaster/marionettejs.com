<html>
  <head>
    <title>marionette.collectionview - Marionette.js Docs</title>
    <link rel="stylesheet" href="../../styles/main.css">
  </head>
  <body>
    <div class="docs">
      <div class="docs__sidebar">
        <select>
          
            <option value="v0.1.0">v0.1.0</option>
          
            <option value="v0.10.0">v0.10.0</option>
          
            <option value="v0.10.1">v0.10.1</option>
          
            <option value="v0.10.2">v0.10.2</option>
          
            <option value="v0.2.0">v0.2.0</option>
          
            <option value="v0.2.1">v0.2.1</option>
          
            <option value="v0.2.2">v0.2.2</option>
          
            <option value="v0.2.3">v0.2.3</option>
          
            <option value="v0.2.4">v0.2.4</option>
          
            <option value="v0.2.5">v0.2.5</option>
          
            <option value="v0.2.6">v0.2.6</option>
          
            <option value="v0.3.0">v0.3.0</option>
          
            <option value="v0.3.1">v0.3.1</option>
          
            <option value="v0.4.0">v0.4.0</option>
          
            <option value="v0.4.1">v0.4.1</option>
          
            <option value="v0.4.1a">v0.4.1a</option>
          
            <option value="v0.4.2">v0.4.2</option>
          
            <option value="v0.4.3">v0.4.3</option>
          
            <option value="v0.4.4">v0.4.4</option>
          
            <option value="v0.4.5">v0.4.5</option>
          
            <option value="v0.4.6">v0.4.6</option>
          
            <option value="v0.4.7">v0.4.7</option>
          
            <option value="v0.4.8">v0.4.8</option>
          
            <option value="v0.5.0">v0.5.0</option>
          
            <option value="v0.5.1">v0.5.1</option>
          
            <option value="v0.5.2">v0.5.2</option>
          
            <option value="v0.6.0">v0.6.0</option>
          
            <option value="v0.6.1">v0.6.1</option>
          
            <option value="v0.6.2">v0.6.2</option>
          
            <option value="v0.6.3">v0.6.3</option>
          
            <option value="v0.7.0">v0.7.0</option>
          
            <option value="v0.7.1">v0.7.1</option>
          
            <option value="v0.7.2">v0.7.2</option>
          
            <option value="v0.7.3">v0.7.3</option>
          
            <option value="v0.7.4">v0.7.4</option>
          
            <option value="v0.7.5">v0.7.5</option>
          
            <option value="v0.7.6">v0.7.6</option>
          
            <option value="v0.8.0">v0.8.0</option>
          
            <option value="v0.8.1">v0.8.1</option>
          
            <option value="v0.8.2">v0.8.2</option>
          
            <option value="v0.8.3">v0.8.3</option>
          
            <option value="v0.8.4">v0.8.4</option>
          
            <option value="v0.9.0">v0.9.0</option>
          
            <option value="v0.9.1">v0.9.1</option>
          
            <option value="v0.9.10">v0.9.10</option>
          
            <option value="v0.9.11">v0.9.11</option>
          
            <option value="v0.9.12">v0.9.12</option>
          
            <option value="v0.9.13">v0.9.13</option>
          
            <option value="v0.9.2">v0.9.2</option>
          
            <option value="v0.9.3">v0.9.3</option>
          
            <option value="v0.9.4">v0.9.4</option>
          
            <option value="v0.9.5">v0.9.5</option>
          
            <option value="v0.9.6">v0.9.6</option>
          
            <option value="v0.9.7">v0.9.7</option>
          
            <option value="v0.9.8">v0.9.8</option>
          
            <option value="v0.9.9">v0.9.9</option>
          
            <option value="v1.0.0">v1.0.0</option>
          
            <option value="v1.0.0-beta1">v1.0.0-beta1</option>
          
            <option value="v1.0.0-beta2">v1.0.0-beta2</option>
          
            <option value="v1.0.0-beta3">v1.0.0-beta3</option>
          
            <option value="v1.0.0-beta4">v1.0.0-beta4</option>
          
            <option value="v1.0.0-beta5">v1.0.0-beta5</option>
          
            <option value="v1.0.0-beta6">v1.0.0-beta6</option>
          
            <option value="v1.0.0-rc1">v1.0.0-rc1</option>
          
            <option value="v1.0.0-rc2">v1.0.0-rc2</option>
          
            <option value="v1.0.0-rc3">v1.0.0-rc3</option>
          
            <option value="v1.0.0-rc4">v1.0.0-rc4</option>
          
            <option value="v1.0.0-rc5">v1.0.0-rc5</option>
          
            <option value="v1.0.0-rc6">v1.0.0-rc6</option>
          
            <option value="v1.0.1">v1.0.1</option>
          
            <option value="v1.0.2">v1.0.2</option>
          
            <option value="v1.0.3">v1.0.3</option>
          
            <option value="v1.0.4">v1.0.4</option>
          
            <option value="v1.1.0">v1.1.0</option>
          
            <option value="v1.2.0">v1.2.0</option>
          
            <option value="v1.2.1">v1.2.1</option>
          
            <option value="v1.2.2">v1.2.2</option>
          
            <option value="v1.2.3">v1.2.3</option>
          
            <option value="v1.3.0">v1.3.0</option>
          
            <option value="v1.4.0">v1.4.0</option>
          
            <option value="v1.4.0beta">v1.4.0beta</option>
          
            <option value="v1.4.1">v1.4.1</option>
          
            <option value="v1.5.0">v1.5.0</option>
          
            <option value="v1.5.1">v1.5.1</option>
          
            <option value="v1.6.0">v1.6.0</option>
          
            <option value="v1.6.1">v1.6.1</option>
          
            <option value="v1.6.2">v1.6.2</option>
          
            <option value="v1.6.3">v1.6.3</option>
          
            <option value="v1.6.4">v1.6.4</option>
          
            <option value="v1.7">v1.7</option>
          
            <option value="v1.7.1">v1.7.1</option>
          
            <option value="v1.7.2">v1.7.2</option>
          
            <option value="v1.7.3">v1.7.3</option>
          
            <option value="v1.7.4">v1.7.4</option>
          
            <option value="v1.8.0">v1.8.0</option>
          
            <option value="v1.8.1">v1.8.1</option>
          
            <option value="v1.8.2">v1.8.2</option>
          
            <option value="v1.8.3">v1.8.3</option>
          
            <option value="v1.8.4">v1.8.4</option>
          
            <option value="v1.8.5">v1.8.5</option>
          
            <option value="v1.8.6">v1.8.6</option>
          
            <option value="v1.8.7">v1.8.7</option>
          
            <option value="v1.8.8">v1.8.8</option>
          
            <option value="v2.0.0">v2.0.0</option>
          
            <option value="v2.0.0-pre.1">v2.0.0-pre.1</option>
          
            <option value="v2.0.0-pre.2">v2.0.0-pre.2</option>
          
            <option value="v2.0.1">v2.0.1</option>
          
            <option value="v2.0.2">v2.0.2</option>
          
            <option value="v2.0.3">v2.0.3</option>
          
            <option value="v2.1.0">v2.1.0</option>
          
            <option value="v2.1.0-pre">v2.1.0-pre</option>
          
            <option value="v2.2.0">v2.2.0</option>
          
            <option value="v2.2.0-pre">v2.2.0-pre</option>
          
            <option value="v2.2.0-pre.2">v2.2.0-pre.2</option>
          
            <option value="v2.2.1">v2.2.1</option>
          
        </select>
        <nav>
          
            <a href="marionette.application.html">marionette.application</a>
          
            <a href="marionette.application.module.html">marionette.application.module</a>
          
            <a href="marionette.approuter.html">marionette.approuter</a>
          
            <a href="marionette.behavior.html">marionette.behavior</a>
          
            <a href="marionette.behaviors.html">marionette.behaviors</a>
          
            <a href="marionette.callbacks.html">marionette.callbacks</a>
          
            <a href="marionette.collectionview.html">marionette.collectionview</a>
          
            <a href="marionette.compositeview.html">marionette.compositeview</a>
          
            <a href="marionette.configuration.html">marionette.configuration</a>
          
            <a href="marionette.controller.html">marionette.controller</a>
          
            <a href="marionette.functions.html">marionette.functions</a>
          
            <a href="marionette.itemview.html">marionette.itemview</a>
          
            <a href="marionette.layoutview.html">marionette.layoutview</a>
          
            <a href="marionette.region.html">marionette.region</a>
          
            <a href="marionette.regionmanager.html">marionette.regionmanager</a>
          
            <a href="marionette.renderer.html">marionette.renderer</a>
          
            <a href="marionette.templatecache.html">marionette.templatecache</a>
          
            <a href="marionette.view.html">marionette.view</a>
          
        </nav>
      </div>
      <div class="docs__content">
        <pre>{
  &quot;tag&quot;: &quot;v2.0.0&quot;,
  &quot;basename&quot;: &quot;marionette.collectionview&quot;,
  &quot;filenane&quot;: &quot;marionette.collectionview.md&quot;,
  &quot;pathname&quot;: &quot;/Users/sam/Desktop/repos/marionettejs.com/.grunt/compileDocs/1412653309300/v2.0.0&quot;,
  &quot;contents&quot;: &quot;&lt;h1&gt;&lt;a name=\&quot;marionette-collectionview\&quot; class=\&quot;anchor\&quot; href=\&quot;#marionette-collectionview\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Marionette.CollectionView&lt;/h1&gt;&lt;p&gt;The &lt;code&gt;CollectionView&lt;/code&gt; will loop through all of the models in the\nspecified collection, render each of them using a specified &lt;code&gt;childView&lt;/code&gt;,\nthen append the results of the child view&amp;#39;s &lt;code&gt;el&lt;/code&gt; to the collection view&amp;#39;s\n&lt;code&gt;el&lt;/code&gt;. By default the &lt;code&gt;CollectionView&lt;/code&gt; will maintain a sorted collection&amp;#39;s order\nin the DOM. This behavior can be disabled by specifying &lt;code&gt;{sort: false}&lt;/code&gt; on initialize.&lt;/p&gt;\n&lt;p&gt;CollectionView extends directly from Marionette.View. Please see\n&lt;a href=\&quot;marionette.view.md\&quot;&gt;the Marionette.View documentation&lt;/a&gt;\nfor more information on available features and functionality.&lt;/p&gt;\n&lt;p&gt;Additionally, interactions with Marionette.Region\nwill provide features such as &lt;code&gt;onShow&lt;/code&gt; callbacks, etc. Please see\n&lt;a href=\&quot;marionette.region.md\&quot;&gt;the Region documentation&lt;/a&gt; for more information.&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;documentation-index\&quot; class=\&quot;anchor\&quot; href=\&quot;#documentation-index\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Documentation Index&lt;/h2&gt;&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionviews-childview\&quot;&gt;CollectionView&amp;#39;s &lt;code&gt;childView&lt;/code&gt;&lt;/a&gt;&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionviews-getchildview\&quot;&gt;CollectionView&amp;#39;s &lt;code&gt;getChildView&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionviews-childviewoptions\&quot;&gt;CollectionView&amp;#39;s &lt;code&gt;childViewOptions&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionviews-childvieweventprefix\&quot;&gt;CollectionView&amp;#39;s &lt;code&gt;childViewEventPrefix&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionviews-childevents\&quot;&gt;CollectionView&amp;#39;s &lt;code&gt;childEvents&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionviews-buildchildview\&quot;&gt;CollectionView&amp;#39;s &lt;code&gt;buildChildView&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionviews-addchildview\&quot;&gt;CollectionView&amp;#39;s &lt;code&gt;addChild&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionviews-emptyview\&quot;&gt;CollectionView&amp;#39;s &lt;code&gt;emptyView&lt;/code&gt;&lt;/a&gt;&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionviews-getemptyview\&quot;&gt;CollectionView&amp;#39;s &lt;code&gt;getEmptyView&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionviews-emptyviewoptions\&quot;&gt;CollectionView&amp;#39;s &lt;code&gt;emptyViewOptions&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#callback-methods\&quot;&gt;Callback Methods&lt;/a&gt;&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&quot;#onbeforerender-callback\&quot;&gt;onBeforeRender callback&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#onrender-callback\&quot;&gt;onRender callback&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#beforedestroy-callback\&quot;&gt;onBeforeDestroy callback&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#ondestroy-callback\&quot;&gt;onDestroy callback&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#onbeforeaddchild-callback\&quot;&gt;onBeforeAddChild callback&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#onaddchild-callback\&quot;&gt;onAddChild callback&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#onbeforeremovechild-callback\&quot;&gt;onBeforeRemoveChild callback&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#onremovechild-callback\&quot;&gt;onRemoveChild callback&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionview-events\&quot;&gt;CollectionView Events&lt;/a&gt;&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&quot;#beforerender-event\&quot;&gt;&amp;quot;before:render&amp;quot; event&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#render-event\&quot;&gt;&amp;quot;render&amp;quot; event&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#beforedestroy-event\&quot;&gt;&amp;quot;before:destroy&amp;quot; event&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#destroy--destroycollection-event\&quot;&gt;&amp;quot;destroy&amp;quot; / &amp;quot;destroy:collection&amp;quot; event&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#beforeaddchild--addchild-event\&quot;&gt;&amp;quot;before:add:child&amp;quot; / &amp;quot;add:child&amp;quot; event&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#beforeremovechild-event\&quot;&gt;&amp;quot;before:remove:child event&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#removechild-event\&quot;&gt;&amp;quot;remove:child&amp;quot; event&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#childview-event-bubbling-from-child-views\&quot;&gt;&amp;quot;childview:*&amp;quot; event bubbling from child views&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionview-render\&quot;&gt;CollectionView render&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionview-automatic-rendering\&quot;&gt;CollectionView: Automatic Rendering&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionview-re-render-collection\&quot;&gt;CollectionView: Re-render Collection&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionviews-attachhtml\&quot;&gt;CollectionView&amp;#39;s attachHtml&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionviews-children\&quot;&gt;CollectionView&amp;#39;s children&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#collectionview-destroy\&quot;&gt;CollectionView destroy&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2&gt;&lt;a name=\&quot;collectionviews-childview\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionviews-childview\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView&amp;#39;s &lt;code&gt;childView&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;Specify a &lt;code&gt;childView&lt;/code&gt; in your collection view definition. This must be\na Backbone view object definition, not an instance. It can be any\n&lt;code&gt;Backbone.View&lt;/code&gt; or be derived from &lt;code&gt;Marionette.ItemView&lt;/code&gt;.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyChildView = Backbone.Marionette.ItemView.extend({});\n\nBackbone.Marionette.CollectionView.extend({\n  childView: MyChildView\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Child views must be defined before they are referenced by the\n&lt;code&gt;childView&lt;/code&gt; attribute in a collection view definition. Use &lt;code&gt;getChildView&lt;/code&gt;\nto lookup the definition as child views are instantiated.&lt;/p&gt;\n&lt;p&gt;Alternatively, you can specify a &lt;code&gt;childView&lt;/code&gt; in the options for\nthe constructor:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyCollectionView = Backbone.Marionette.CollectionView.extend({...});\n\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MyCollectionView({\n  childView: MyChildView\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If you do not specify a &lt;code&gt;childView&lt;/code&gt;, an exception will be thrown\nstating that you must specify a &lt;code&gt;childView&lt;/code&gt;.&lt;/p&gt;\n&lt;h3&gt;&lt;a name=\&quot;collectionviews-getchildview\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionviews-getchildview\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView&amp;#39;s &lt;code&gt;getChildView&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;The value returned by this method is the &lt;code&gt;ChildView&lt;/code&gt; class that will be instantiated when a &lt;code&gt;Model&lt;/code&gt; needs to be initially rendered.\nThis method also gives you the ability to customize per &lt;code&gt;Model&lt;/code&gt; &lt;code&gt;ChildViews&lt;/code&gt;.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; FooBar = Backbone.Model.extend({\n  defaults: {\n    isFoo: &lt;span class=\&quot;hljs-literal\&quot;&gt;false&lt;/span&gt;\n  }\n});\n\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; FooView = Backbone.Marionette.ItemView.extend({\n  template: &lt;span class=\&quot;hljs-string\&quot;&gt;&#x27;#foo-template&#x27;&lt;/span&gt;\n});\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; BarView = Backbone.Marionette.ItemView.extend({\n  template: &lt;span class=\&quot;hljs-string\&quot;&gt;&#x27;#bar-template&#x27;&lt;/span&gt;\n});\n\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; MyCollectionView = Backbone.Marionette.CollectionView.extend({\n  getItemView: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(item)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// Choose which view class to render,&lt;/span&gt;\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// depending on the properties of the item model&lt;/span&gt;\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;if&lt;/span&gt;  (item.get(&lt;span class=\&quot;hljs-string\&quot;&gt;&#x27;isFoo&#x27;&lt;/span&gt;)) {\n      &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; FooView;\n    }\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;else&lt;/span&gt; {\n      &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; BarView;\n    }\n  }\n});\n\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; collectionView = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MyCollectionView();\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; foo = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; FooBar({\n  isFoo: &lt;span class=\&quot;hljs-literal\&quot;&gt;true&lt;/span&gt;\n});\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; bar = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; FooBar({\n  isFoo: &lt;span class=\&quot;hljs-literal\&quot;&gt;false&lt;/span&gt;\n});\n\n&lt;span class=\&quot;hljs-comment\&quot;&gt;// Renders a FooView&lt;/span&gt;\ncollectionView.collection.add(foo);\n\n&lt;span class=\&quot;hljs-comment\&quot;&gt;// Renders a BarView&lt;/span&gt;\ncollectionView.collection.add(bar);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;collectionviews-childviewoptions\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionviews-childviewoptions\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView&amp;#39;s &lt;code&gt;childViewOptions&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;There may be scenarios where you need to pass data from your parent\ncollection view in to each of the childView instances. To do this, provide\na &lt;code&gt;childViewOptions&lt;/code&gt; definition on your collection view as an object\nliteral. This will be passed to the constructor of your childView as part\nof the &lt;code&gt;options&lt;/code&gt;.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;ChildView = Backbone.Marionette.ItemView({\n  initialize: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(options)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\&quot;hljs-built_in\&quot;&gt;console&lt;/span&gt;.log(options.foo); &lt;span class=\&quot;hljs-comment\&quot;&gt;// =&amp;gt; \&quot;bar\&quot;&lt;/span&gt;\n  }\n});\n\nCollectionView = Backbone.Marionette.CollectionView({\n  childView: ChildView,\n\n  childViewOptions: {\n    foo: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;bar\&quot;&lt;/span&gt;\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You can also specify the &lt;code&gt;childViewOptions&lt;/code&gt; as a function, if you need to\ncalculate the values to return at runtime. The model will be passed into\nthe function should you need access to it when calculating\n&lt;code&gt;childViewOptions&lt;/code&gt;. The function must return an object, and the attributes\nof the object will be copied to the &lt;code&gt;childView&lt;/code&gt; instance&amp;#39;s options.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;CollectionView = Backbone.Marionette.CollectionView({\n  childViewOptions: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(model, index)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// do some calculations based on the model&lt;/span&gt;\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; {\n      foo: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;bar\&quot;&lt;/span&gt;,\n      childIndex: index\n    }\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;collectionviews-childvieweventprefix\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionviews-childvieweventprefix\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView&amp;#39;s &lt;code&gt;childViewEventPrefix&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;You can customize the event prefix for events that are forwarded\nthrough the collection view. To do this, set the &lt;code&gt;childViewEventPrefix&lt;/code&gt;\non the collection view.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; CV = Marionette.CollectionView.extend({\n  childViewEventPrefix: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;some:prefix\&quot;&lt;/span&gt;\n});\n\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; c = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; CV({\n  collection: myCol\n});\n\nc.on(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;some:prefix:render\&quot;&lt;/span&gt;, &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// child view was rendered&lt;/span&gt;\n});\n\nc.render();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The &lt;code&gt;childViewEventPrefix&lt;/code&gt; can be provided in the view definition or\nin the constructor function call, to get a view instance.&lt;/p&gt;\n&lt;h3&gt;&lt;a name=\&quot;collectionviews-childevents\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionviews-childevents\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView&amp;#39;s &lt;code&gt;childEvents&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;You can specify a &lt;code&gt;childEvents&lt;/code&gt; hash or method which allows you to capture all bubbling childEvents without having to manually set bindings. The keys of the hash can either be a function or a string that is the name of a method on the collection view.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;childEvents: {\n  &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;render\&quot;&lt;/span&gt;: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\&quot;hljs-built_in\&quot;&gt;console&lt;/span&gt;.log(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;a childView has been rendered\&quot;&lt;/span&gt;);\n  },\n  &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;onChildDestroy\&quot;&lt;/span&gt;: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;someFn\&quot;&lt;/span&gt; &lt;span class=\&quot;hljs-comment\&quot;&gt;// where the collection view has a method &#x60;someFn&#x60;&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You can also use a method for &lt;code&gt;childEvents&lt;/code&gt; that returns a hash.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;childEvents: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n  &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; {\n    &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;render\&quot;&lt;/span&gt;: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n      &lt;span class=\&quot;hljs-built_in\&quot;&gt;console&lt;/span&gt;.log(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;a childView has been rendered\&quot;&lt;/span&gt;);\n    }\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;collectionviews-buildchildview\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionviews-buildchildview\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView&amp;#39;s &lt;code&gt;buildChildView&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;When a custom view instance needs to be created for the &lt;code&gt;childView&lt;/code&gt; that\nrepresents a child, override the &lt;code&gt;buildChildView&lt;/code&gt; method. This method\ntakes three parameters and returns a view instance to be used as the\nchild view.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;buildChildView: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(child, ChildViewClass, childViewOptions)&lt;/span&gt;&lt;/span&gt;{\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// build the final list of options for the childView class&lt;/span&gt;\n  &lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; options = _.extend({model: child}, childViewOptions);\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// create the child view instance&lt;/span&gt;\n  &lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; view = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; ChildViewClass(options);\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// return it&lt;/span&gt;\n  &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; view;\n},\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;collectionviews-addchild\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionviews-addchild\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView&amp;#39;s &lt;code&gt;addChild&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;The &lt;code&gt;addChild&lt;/code&gt; method is responsible for rendering the &lt;code&gt;childViews&lt;/code&gt; and adding them to the HTML for the &lt;code&gt;collectionView&lt;/code&gt; instance. It is also responsible for triggering the events per &lt;code&gt;ChildView&lt;/code&gt;. In most cases you should not override this method. However if you do want to short circut this method, it can be accomplished via the following.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CollectionView.extend({\n  addChild: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(child, ChildView, index)&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;if&lt;/span&gt; (child.shouldBeShown()) {\n      Backbone.Marionette.CollectionView.prototype.addChild.apply(&lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;, &lt;span class=\&quot;hljs-built_in\&quot;&gt;arguments&lt;/span&gt;);\n    }\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&lt;a name=\&quot;collectionviews-emptyview\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionviews-emptyview\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView&amp;#39;s &lt;code&gt;emptyView&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;When a collection has no children, and you need to render a view other than\nthe list of childViews, you can specify an &lt;code&gt;emptyView&lt;/code&gt; attribute on your\ncollection view.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;NoChildsView = Backbone.Marionette.ItemView.extend({\n  template: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;#show-no-children-message-template\&quot;&lt;/span&gt;\n});\n\nBackbone.Marionette.CollectionView.extend({\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// ...&lt;/span&gt;\n\n  emptyView: NoChildsView\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;collectionviews-getemptyview\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionviews-getemptyview\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView&amp;#39;s &lt;code&gt;getEmptyView&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;If you need the &lt;code&gt;emptyView&lt;/code&gt;&amp;#39;s class chosen dynamically, specify &lt;code&gt;getEmptyView&lt;/code&gt;:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CollectionView.extend({\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// ...&lt;/span&gt;\n\n  getEmptyView: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// custom logic&lt;/span&gt;\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; NoChildsView;\n  }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This will render the &lt;code&gt;emptyView&lt;/code&gt; and display the message that needs to\nbe displayed when there are no children.&lt;/p&gt;\n&lt;p&gt;If you want to control when the empty view is rendered, you can override\n&lt;code&gt;isEmpty&lt;/code&gt;:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CollectionView.extend({\n  isEmpty: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(collection)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// some logic to calculate if the view should be rendered as empty&lt;/span&gt;\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; someBoolean;\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;collectionviews-emptyviewoptions\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionviews-emptyviewoptions\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView&amp;#39;s &lt;code&gt;emptyViewOptions&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Similar to &lt;code&gt;childView&lt;/code&gt; and &lt;code&gt;childViewOptions&lt;/code&gt;, there is an &lt;code&gt;emptyViewOptions&lt;/code&gt; property that will be passed to the &lt;code&gt;emptyView&lt;/code&gt; constructor. It can be provided as an object literal or as a function.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;EmptyView = Backbone.Marionette.ItemView({\n  initialize: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(options)&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-built_in\&quot;&gt;console&lt;/span&gt;.log(options.foo); &lt;span class=\&quot;hljs-comment\&quot;&gt;// =&amp;gt; \&quot;bar\&quot;&lt;/span&gt;\n  }\n});\n\nCollectionView = Backbone.Marionette.CollectionView({\n  emptyView: EmptyView,\n\n  emptyViewOptions: {\n    foo: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;bar\&quot;&lt;/span&gt;\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&lt;a name=\&quot;callback-methods\&quot; class=\&quot;anchor\&quot; href=\&quot;#callback-methods\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Callback Methods&lt;/h2&gt;&lt;p&gt;There are several callback methods that can be provided on a\n&lt;code&gt;CollectionView&lt;/code&gt;. If they are found, they will be called by the\nview&amp;#39;s base methods. These callback methods are intended to be\nhandled within the view definition directly.&lt;/p&gt;\n&lt;h3&gt;&lt;a name=\&quot;onbeforerender-callback\&quot; class=\&quot;anchor\&quot; href=\&quot;#onbeforerender-callback\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;onBeforeRender callback&lt;/h3&gt;&lt;p&gt;A &lt;code&gt;onBeforeRender&lt;/code&gt; callback will be called just prior to rendering\nthe collection view.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CollectionView.extend({\n  onBeforeRender: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// do stuff here&lt;/span&gt;\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;onrender-callback\&quot; class=\&quot;anchor\&quot; href=\&quot;#onrender-callback\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;onRender callback&lt;/h3&gt;&lt;p&gt;After the view has been rendered, a &lt;code&gt;onRender&lt;/code&gt; method will be called.\nYou can implement this in your view to provide custom code for dealing\nwith the view&amp;#39;s &lt;code&gt;el&lt;/code&gt; after it has been rendered:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CollectionView.extend({\n  onRender: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// do stuff here&lt;/span&gt;\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;onbeforedestroy-callback\&quot; class=\&quot;anchor\&quot; href=\&quot;#onbeforedestroy-callback\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;onBeforeDestroy callback&lt;/h3&gt;&lt;p&gt;This method is called just before destroying the view.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CollectionView.extend({\n  onBeforeDestroy: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// do stuff here&lt;/span&gt;\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;ondestroy-callback\&quot; class=\&quot;anchor\&quot; href=\&quot;#ondestroy-callback\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;onDestroy callback&lt;/h3&gt;&lt;p&gt;This method is called just after destroying the view.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CollectionView.extend({\n  onDestroy: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// do stuff here&lt;/span&gt;\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;onbeforeaddchild-callback\&quot; class=\&quot;anchor\&quot; href=\&quot;#onbeforeaddchild-callback\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;onBeforeAddChild callback&lt;/h3&gt;&lt;p&gt;This callback function allows you to know when a child / child view\ninstance is about to be added to the collection view. It provides access to\nthe view instance for the child that was added.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CollectionView.extend({\n  onBeforeAddChild: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(childView)&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// work with the childView instance, here&lt;/span&gt;\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;onaddchild-callback\&quot; class=\&quot;anchor\&quot; href=\&quot;#onaddchild-callback\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;onAddChild callback&lt;/h3&gt;&lt;p&gt;This callback function allows you to know when a child / child view\ninstance has been added to the collection view. It provides access to\nthe view instance for the child that was added.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CollectionView.extend({\n  onAddChild: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(childView)&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// work with the childView instance, here&lt;/span&gt;\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;onbeforeremovechild-callback\&quot; class=\&quot;anchor\&quot; href=\&quot;#onbeforeremovechild-callback\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;onBeforeRemoveChild callback&lt;/h3&gt;&lt;p&gt;This callback function allows you to know when a &lt;code&gt;childView&lt;/code&gt;\ninstance is about to be removed from the &lt;code&gt;collectionView&lt;/code&gt;. It provides access to\nthe view instance for the child that was removed.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CollectionView.extend({\n  onBeforeRemoveChild: function(childView){\n    // work with the childView instance, here\n  }\n});\n\n### onRemoveChild callback\n\nThis callback function allows you to know when a child / childView\ninstance has been deleted or removed from the\ncollection.\n\n&#x60;&#x60;&#x60;js\nBackbone.Marionette.CollectionView.extend({\n  onRemoveChild: function(childView){\n    // work with the childView instance, here\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&lt;a name=\&quot;collectionview-events\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionview-events\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView Events&lt;/h2&gt;&lt;p&gt;There are several events that will be triggered during the life\nof a collection view. Each of these events is called with the\n&lt;a href=\&quot;./marionette.functions.md\&quot;&gt;Marionette.triggerMethod&lt;/a&gt; function,\nwhich calls a corresponding &amp;quot;on{EventName}&amp;quot; method on the\nview instance (see &lt;a href=\&quot;#callback-methods\&quot;&gt;above&lt;/a&gt;).&lt;/p&gt;\n&lt;h3&gt;&lt;a name=\&quot;-before-render-event\&quot; class=\&quot;anchor\&quot; href=\&quot;#-before-render-event\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&amp;quot;before:render&amp;quot; event&lt;/h3&gt;&lt;p&gt;Triggers just prior to the view being rendered. Also triggered as\n&amp;quot;collection:before:render&amp;quot; / &lt;code&gt;onCollectionBeforeRender&lt;/code&gt;.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyView = Backbone.Marionette.CollectionView.extend({...});\n\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; myView = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MyView();\n\nmyView.on(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;before:render\&quot;&lt;/span&gt;, &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n  alert(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;the collection view is about to be rendered\&quot;&lt;/span&gt;);\n});\n\nmyView.render();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;-render-event\&quot; class=\&quot;anchor\&quot; href=\&quot;#-render-event\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&amp;quot;render&amp;quot; event&lt;/h3&gt;&lt;p&gt;A &amp;quot;collection:rendered&amp;quot; / &lt;code&gt;onCollectionRendered&lt;/code&gt; event will also be fired. This allows you to\nadd more than one callback to execute after the view is rendered,\nand allows parent views and other parts of the application to\nknow that the view was rendered.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyView = Backbone.Marionette.CollectionView.extend({...});\n\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; myView = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MyView();\n\nmyView.on(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;render\&quot;&lt;/span&gt;, &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n  alert(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;the collection view was rendered!\&quot;&lt;/span&gt;);\n});\n\nmyView.on(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;collection:rendered\&quot;&lt;/span&gt;, &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n  alert(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;the collection view was rendered!\&quot;&lt;/span&gt;);\n});\n\nmyView.render();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;-before-destroy-event\&quot; class=\&quot;anchor\&quot; href=\&quot;#-before-destroy-event\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&amp;quot;before:destroy&amp;quot; event&lt;/h3&gt;&lt;p&gt;Triggered just before destroying the view. A &amp;quot;before:destroy:collection&amp;quot; /\n&lt;code&gt;onBeforeDestroyCollection&lt;/code&gt; event will also be fired&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyView = Backbone.Marionette.CollectionView.extend({...});\n\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; myView = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MyView();\n\nmyView.on(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;before:destroy:collection\&quot;&lt;/span&gt;, &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n  alert(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;the collection view is about to be destroyed\&quot;&lt;/span&gt;);\n});\n\nmyView.destroy();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;-destroy-destroy-collection-event\&quot; class=\&quot;anchor\&quot; href=\&quot;#-destroy-destroy-collection-event\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&amp;quot;destroy&amp;quot; / &amp;quot;destroy:collection&amp;quot; event&lt;/h3&gt;&lt;p&gt;Triggered just after destroying the view, both with corresponding\nmethod calls.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyView = Backbone.Marionette.CollectionView.extend({...});\n\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; myView = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MyView();\n\nmyView.on(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;destroy:collection\&quot;&lt;/span&gt;, &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n  alert(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;the collection view is now destroyed\&quot;&lt;/span&gt;);\n});\n\nmyView.destroy();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;-before-add-child-add-child-event\&quot; class=\&quot;anchor\&quot; href=\&quot;#-before-add-child-add-child-event\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&amp;quot;before:add:child&amp;quot; / &amp;quot;add:child&amp;quot; event&lt;/h3&gt;&lt;p&gt;The &amp;quot;before:add:child&amp;quot; event and corresponding &lt;code&gt;onBeforeAddChild&lt;/code&gt;\nmethod are triggered just after creating a new &lt;code&gt;childView&lt;/code&gt; instance for\na child that was added to the collection, but before the\nview is rendered and added to the DOM.&lt;/p&gt;\n&lt;p&gt;The &amp;quot;add:child&amp;quot; event and corresponding &lt;code&gt;onAddChild&lt;/code&gt;\nmethod are triggered after rendering the view and adding it to the\nview&amp;#39;s DOM element.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; MyCV = Marionette.CollectionView.extend({\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// ...&lt;/span&gt;\n\n  onBeforeAddChild: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// ...&lt;/span&gt;\n  },\n\n  onAddChild: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// ...&lt;/span&gt;\n  }\n});\n\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; cv = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MyCV({...});\n\ncv.on(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;before:add:child\&quot;&lt;/span&gt;, &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(viewInstance)&lt;/span&gt;&lt;/span&gt;{\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// ...&lt;/span&gt;\n});\n\ncv.on(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;add:child\&quot;&lt;/span&gt;, &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(viewInstance)&lt;/span&gt;&lt;/span&gt;{\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// ...&lt;/span&gt;\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;-before-remove-child\&quot; class=\&quot;anchor\&quot; href=\&quot;#-before-remove-child\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&amp;quot;before:remove:child&amp;quot;&lt;/h3&gt;&lt;p&gt;This is triggered after the childView instance has been\nremoved from the collection, but before it has been destroyed.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;cv.on(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;before:remove:child\&quot;&lt;/span&gt;, &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(childView)&lt;/span&gt;&lt;/span&gt;{\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// ...&lt;/span&gt;\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;-remove-child-event\&quot; class=\&quot;anchor\&quot; href=\&quot;#-remove-child-event\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&amp;quot;remove:child&amp;quot; event&lt;/h3&gt;&lt;p&gt;Triggered after a childView instance has been destroyed and\nremoved, when its child was deleted or removed from the\ncollection.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;cv.on(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;remove:child\&quot;&lt;/span&gt;, &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(viewInstance)&lt;/span&gt;&lt;/span&gt;{\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// ...&lt;/span&gt;\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;-childview-event-bubbling-from-child-views\&quot; class=\&quot;anchor\&quot; href=\&quot;#-childview-event-bubbling-from-child-views\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&amp;quot;childview:*&amp;quot; event bubbling from child views&lt;/h3&gt;&lt;p&gt;When a child view within a collection view triggers an\nevent, that event will bubble up through the parent\ncollection view with &amp;quot;childview:&amp;quot; prepended to the event\nname.&lt;/p&gt;\n&lt;p&gt;That is, if a child view triggers &amp;quot;do:something&amp;quot;, the\nparent collection view will then trigger &amp;quot;childview:do:something&amp;quot;.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;&lt;span class=\&quot;hljs-comment\&quot;&gt;// set up basic collection&lt;/span&gt;\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; myModel = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MyModel();\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; myCollection = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MyCollection();\nmyCollection.add(myModel);\n\n&lt;span class=\&quot;hljs-comment\&quot;&gt;// get the collection view in place&lt;/span&gt;\ncolView = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; CollectionView({\n  collection: myCollection\n});\ncolView.render();\n\n&lt;span class=\&quot;hljs-comment\&quot;&gt;// bind to the collection view&#x27;s events that were bubbled&lt;/span&gt;\n&lt;span class=\&quot;hljs-comment\&quot;&gt;// from the child view&lt;/span&gt;\ncolView.on(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;childview:do:something\&quot;&lt;/span&gt;, &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(childView, msg)&lt;/span&gt;&lt;/span&gt;{\n  alert(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;I said, &#x27;\&quot;&lt;/span&gt; + msg + &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;&#x27;\&quot;&lt;/span&gt;);\n});\n\n&lt;span class=\&quot;hljs-comment\&quot;&gt;// hack, to get the child view and trigger from it&lt;/span&gt;\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; childView = colView.children[myModel.cid];\nchildView.trigger(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;do:something\&quot;&lt;/span&gt;, &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;do something!\&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The result of this will be an alert box that says\n&amp;quot;I said, &amp;#39;do something!&amp;#39;&amp;quot;.&lt;/p&gt;\n&lt;p&gt;Also note that you would not normally grab a reference to\nthe child view the way this is showing. I&amp;#39;m merely using\nthat hack as a way to demonstrate the event bubbling.\nNormally, you would have your child view listening to DOM\nevents or model change events, and then triggering an event\nof its own based on that.&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;collectionview-render\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionview-render\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView render&lt;/h2&gt;&lt;p&gt;The &lt;code&gt;render&lt;/code&gt; method of the collection view is responsible for\nrendering the entire collection. It loops through each of the\nchildren in the collection and renders them individually as an\n&lt;code&gt;childView&lt;/code&gt;.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyCollectionView = Backbone.Marionette.CollectionView.extend({...});\n\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MyCollectionView().render().done(&lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// all of the children are now rendered. do stuff here.&lt;/span&gt;\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&lt;a name=\&quot;collectionview-automatic-rendering\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionview-automatic-rendering\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView: Automatic Rendering&lt;/h2&gt;&lt;p&gt;The collection view binds to the &amp;quot;add&amp;quot;, &amp;quot;remove&amp;quot; and &amp;quot;reset&amp;quot; events of the\ncollection that is specified.&lt;/p&gt;\n&lt;p&gt;When the collection for the view is &amp;quot;reset&amp;quot;, the view will call &lt;code&gt;render&lt;/code&gt; on\nitself and re-render the entire collection.&lt;/p&gt;\n&lt;p&gt;When a model is added to the collection, the collection view will render that\none model in to the collection of child views.&lt;/p&gt;\n&lt;p&gt;When a model is removed from a collection (or destroyed / deleted), the collection\nview will destroy and remove that model&amp;#39;s child view.&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;collectionview-re-render-collection\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionview-re-render-collection\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView: Re-render Collection&lt;/h2&gt;&lt;p&gt;If you need to re-render the entire collection, you can call the\n&lt;code&gt;view.render&lt;/code&gt; method. This method takes care of destroying all of\nthe child views that may have previously been opened.&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;collectionviews-attachhtml\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionviews-attachhtml\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView&amp;#39;s attachHtml&lt;/h2&gt;&lt;p&gt;By default the collection view will append the HTML of each ChildView\ninto the element buffer, and then call jQuery&amp;#39;s &lt;code&gt;.append&lt;/code&gt; once at the\nend to move the HTML into the collection view&amp;#39;s &lt;code&gt;el&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;You can override this by specifying an &lt;code&gt;attachHtml&lt;/code&gt; method in your\nview definition. This method takes three parameters and has no return\nvalue.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CollectionView.extend({\n\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// The default implementation:&lt;/span&gt;\n  attachHtml: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(collectionView, childView, index)&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;if&lt;/span&gt; (collectionView.isBuffering) {\n      &lt;span class=\&quot;hljs-comment\&quot;&gt;// buffering happens on reset events and initial renders&lt;/span&gt;\n      &lt;span class=\&quot;hljs-comment\&quot;&gt;// in order to reduce the number of inserts into the&lt;/span&gt;\n      &lt;span class=\&quot;hljs-comment\&quot;&gt;// document, which are expensive.&lt;/span&gt;\n      collectionView.elBuffer.appendChild(childView.el);\n    }\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;else&lt;/span&gt; {\n      &lt;span class=\&quot;hljs-comment\&quot;&gt;// If we&#x27;ve already rendered the main collection, just&lt;/span&gt;\n      &lt;span class=\&quot;hljs-comment\&quot;&gt;// append the new children directly into the element.&lt;/span&gt;\n      collectionView.$el.append(childView.el);\n    }\n  },\n\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// Called after all children have been appended into the elBuffer&lt;/span&gt;\n  appendHtml: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(collectionView, buffer)&lt;/span&gt; &lt;/span&gt;{\n    collectionView.$el.append(buffer);\n  },\n\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// called on initialize and after appendHtml is called&lt;/span&gt;\n  initRenderBuffer: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;.elBuffer = &lt;span class=\&quot;hljs-built_in\&quot;&gt;document&lt;/span&gt;.createDocumentFragment();\n  }\n\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The first parameter is the instance of the collection view that\nwill receive the HTML from the second parameter, the current child\nview instance.&lt;/p&gt;\n&lt;p&gt;The third parameter, &lt;code&gt;index&lt;/code&gt;, is the index of the\nmodel that this &lt;code&gt;childView&lt;/code&gt; instance represents, in the collection\nthat the model came from. This is useful for sorting a collection\nand displaying the sorted list in the correct order on the screen.&lt;/p&gt;\n&lt;p&gt;Overrides of &lt;code&gt;attachHtml&lt;/code&gt; that don&amp;#39;t take into account the element\nbuffer will work fine, but won&amp;#39;t take advantage of the 60x performance\nincrease the buffer provides.&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;collectionviews-children\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionviews-children\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView&amp;#39;s children&lt;/h2&gt;&lt;p&gt;The CollectionView uses &lt;a href=\&quot;https://github.com/marionettejs/backbone.babysitter\&quot;&gt;Backbone.BabySitter&lt;/a&gt;\nto store and manage its child views. This allows you to easily access\nthe views within the collection view, iterate them, find them by\na given indexer such as the view&amp;#39;s model or collection, and more.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; cv = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; Marionette.CollectionView({\n  collection: someCollection\n});\n\ncv.render();\n\n\n&lt;span class=\&quot;hljs-comment\&quot;&gt;// retrieve a view by model&lt;/span&gt;\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; v = cv.children.findByModel(someModel);\n\n&lt;span class=\&quot;hljs-comment\&quot;&gt;// iterate over all of the views and process them&lt;/span&gt;\ncv.children.each(&lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(view)&lt;/span&gt;&lt;/span&gt;{\n\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// process the &#x60;view&#x60; here&lt;/span&gt;\n\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;For more information on the available features and functionality of\nthe &lt;code&gt;.children&lt;/code&gt;, see the &lt;a href=\&quot;https://github.com/marionettejs/backbone.babysitter\&quot;&gt;Backbone.BabySitter documentation&lt;/a&gt;.&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;collectionview-destroy\&quot; class=\&quot;anchor\&quot; href=\&quot;#collectionview-destroy\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;CollectionView destroy&lt;/h2&gt;&lt;p&gt;CollectionView implements a &lt;code&gt;destroy&lt;/code&gt; method, which is called by the\nregion managers automatically. As part of the implementation, the\nfollowing are performed:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;unbind all &lt;code&gt;listenTo&lt;/code&gt; events&lt;/li&gt;\n&lt;li&gt;unbind all custom view events&lt;/li&gt;\n&lt;li&gt;unbind all DOM events&lt;/li&gt;\n&lt;li&gt;unbind all child views that were rendered&lt;/li&gt;\n&lt;li&gt;remove &lt;code&gt;this.el&lt;/code&gt; from the DOM&lt;/li&gt;\n&lt;li&gt;call an &lt;code&gt;onDestroy&lt;/code&gt; event on the view, if one is provided&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;By providing an &lt;code&gt;onDestroy&lt;/code&gt; event in your view definition, you can\nrun custom code for your view that is fired after your view has been\ndestroyed and cleaned up. This lets you handle any additional clean up\ncode without having to override the &lt;code&gt;destroy&lt;/code&gt; method.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CollectionView.extend({\n  onDestroy: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// custom cleanup or destroying code, here&lt;/span&gt;\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&quot;
}</pre>
        <h1><a name="marionette-collectionview" class="anchor" href="#marionette-collectionview"><span class="header-link"></span></a>Marionette.CollectionView</h1><p>The <code>CollectionView</code> will loop through all of the models in the
specified collection, render each of them using a specified <code>childView</code>,
then append the results of the child view&#39;s <code>el</code> to the collection view&#39;s
<code>el</code>. By default the <code>CollectionView</code> will maintain a sorted collection&#39;s order
in the DOM. This behavior can be disabled by specifying <code>{sort: false}</code> on initialize.</p>
<p>CollectionView extends directly from Marionette.View. Please see
<a href="marionette.view.md">the Marionette.View documentation</a>
for more information on available features and functionality.</p>
<p>Additionally, interactions with Marionette.Region
will provide features such as <code>onShow</code> callbacks, etc. Please see
<a href="marionette.region.md">the Region documentation</a> for more information.</p>
<h2><a name="documentation-index" class="anchor" href="#documentation-index"><span class="header-link"></span></a>Documentation Index</h2><ul>
<li><a href="#collectionviews-childview">CollectionView&#39;s <code>childView</code></a><ul>
<li><a href="#collectionviews-getchildview">CollectionView&#39;s <code>getChildView</code></a></li>
<li><a href="#collectionviews-childviewoptions">CollectionView&#39;s <code>childViewOptions</code></a></li>
<li><a href="#collectionviews-childvieweventprefix">CollectionView&#39;s <code>childViewEventPrefix</code></a></li>
<li><a href="#collectionviews-childevents">CollectionView&#39;s <code>childEvents</code></a></li>
<li><a href="#collectionviews-buildchildview">CollectionView&#39;s <code>buildChildView</code></a></li>
<li><a href="#collectionviews-addchildview">CollectionView&#39;s <code>addChild</code></a></li>
</ul>
</li>
<li><a href="#collectionviews-emptyview">CollectionView&#39;s <code>emptyView</code></a><ul>
<li><a href="#collectionviews-getemptyview">CollectionView&#39;s <code>getEmptyView</code></a></li>
<li><a href="#collectionviews-emptyviewoptions">CollectionView&#39;s <code>emptyViewOptions</code></a></li>
</ul>
</li>
<li><a href="#callback-methods">Callback Methods</a><ul>
<li><a href="#onbeforerender-callback">onBeforeRender callback</a></li>
<li><a href="#onrender-callback">onRender callback</a></li>
<li><a href="#beforedestroy-callback">onBeforeDestroy callback</a></li>
<li><a href="#ondestroy-callback">onDestroy callback</a></li>
<li><a href="#onbeforeaddchild-callback">onBeforeAddChild callback</a></li>
<li><a href="#onaddchild-callback">onAddChild callback</a></li>
<li><a href="#onbeforeremovechild-callback">onBeforeRemoveChild callback</a></li>
<li><a href="#onremovechild-callback">onRemoveChild callback</a></li>
</ul>
</li>
<li><a href="#collectionview-events">CollectionView Events</a><ul>
<li><a href="#beforerender-event">&quot;before:render&quot; event</a></li>
<li><a href="#render-event">&quot;render&quot; event</a></li>
<li><a href="#beforedestroy-event">&quot;before:destroy&quot; event</a></li>
<li><a href="#destroy--destroycollection-event">&quot;destroy&quot; / &quot;destroy:collection&quot; event</a></li>
<li><a href="#beforeaddchild--addchild-event">&quot;before:add:child&quot; / &quot;add:child&quot; event</a></li>
<li><a href="#beforeremovechild-event">&quot;before:remove:child event</a></li>
<li><a href="#removechild-event">&quot;remove:child&quot; event</a></li>
<li><a href="#childview-event-bubbling-from-child-views">&quot;childview:*&quot; event bubbling from child views</a></li>
</ul>
</li>
<li><a href="#collectionview-render">CollectionView render</a></li>
<li><a href="#collectionview-automatic-rendering">CollectionView: Automatic Rendering</a></li>
<li><a href="#collectionview-re-render-collection">CollectionView: Re-render Collection</a></li>
<li><a href="#collectionviews-attachhtml">CollectionView&#39;s attachHtml</a></li>
<li><a href="#collectionviews-children">CollectionView&#39;s children</a></li>
<li><a href="#collectionview-destroy">CollectionView destroy</a></li>
</ul>
<h2><a name="collectionviews-childview" class="anchor" href="#collectionviews-childview"><span class="header-link"></span></a>CollectionView&#39;s <code>childView</code></h2><p>Specify a <code>childView</code> in your collection view definition. This must be
a Backbone view object definition, not an instance. It can be any
<code>Backbone.View</code> or be derived from <code>Marionette.ItemView</code>.</p>
<pre><code class="lang-js">MyChildView = Backbone.Marionette.ItemView.extend({});

Backbone.Marionette.CollectionView.extend({
  childView: MyChildView
});
</code></pre>
<p>Child views must be defined before they are referenced by the
<code>childView</code> attribute in a collection view definition. Use <code>getChildView</code>
to lookup the definition as child views are instantiated.</p>
<p>Alternatively, you can specify a <code>childView</code> in the options for
the constructor:</p>
<pre><code class="lang-js">MyCollectionView = Backbone.Marionette.CollectionView.extend({...});

<span class="hljs-keyword">new</span> MyCollectionView({
  childView: MyChildView
});
</code></pre>
<p>If you do not specify a <code>childView</code>, an exception will be thrown
stating that you must specify a <code>childView</code>.</p>
<h3><a name="collectionviews-getchildview" class="anchor" href="#collectionviews-getchildview"><span class="header-link"></span></a>CollectionView&#39;s <code>getChildView</code></h3><p>The value returned by this method is the <code>ChildView</code> class that will be instantiated when a <code>Model</code> needs to be initially rendered.
This method also gives you the ability to customize per <code>Model</code> <code>ChildViews</code>.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> FooBar = Backbone.Model.extend({
  defaults: {
    isFoo: <span class="hljs-literal">false</span>
  }
});

<span class="hljs-keyword">var</span> FooView = Backbone.Marionette.ItemView.extend({
  template: <span class="hljs-string">'#foo-template'</span>
});
<span class="hljs-keyword">var</span> BarView = Backbone.Marionette.ItemView.extend({
  template: <span class="hljs-string">'#bar-template'</span>
});

<span class="hljs-keyword">var</span> MyCollectionView = Backbone.Marionette.CollectionView.extend({
  getItemView: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> </span>{
    <span class="hljs-comment">// Choose which view class to render,</span>
    <span class="hljs-comment">// depending on the properties of the item model</span>
    <span class="hljs-keyword">if</span>  (item.get(<span class="hljs-string">'isFoo'</span>)) {
      <span class="hljs-keyword">return</span> FooView;
    }
    <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> BarView;
    }
  }
});

<span class="hljs-keyword">var</span> collectionView = <span class="hljs-keyword">new</span> MyCollectionView();
<span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">new</span> FooBar({
  isFoo: <span class="hljs-literal">true</span>
});
<span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> FooBar({
  isFoo: <span class="hljs-literal">false</span>
});

<span class="hljs-comment">// Renders a FooView</span>
collectionView.collection.add(foo);

<span class="hljs-comment">// Renders a BarView</span>
collectionView.collection.add(bar);
</code></pre>
<h3><a name="collectionviews-childviewoptions" class="anchor" href="#collectionviews-childviewoptions"><span class="header-link"></span></a>CollectionView&#39;s <code>childViewOptions</code></h3><p>There may be scenarios where you need to pass data from your parent
collection view in to each of the childView instances. To do this, provide
a <code>childViewOptions</code> definition on your collection view as an object
literal. This will be passed to the constructor of your childView as part
of the <code>options</code>.</p>
<pre><code class="lang-js">ChildView = Backbone.Marionette.ItemView({
  initialize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options)</span> </span>{
    <span class="hljs-built_in">console</span>.log(options.foo); <span class="hljs-comment">// =&gt; "bar"</span>
  }
});

CollectionView = Backbone.Marionette.CollectionView({
  childView: ChildView,

  childViewOptions: {
    foo: <span class="hljs-string">"bar"</span>
  }
});
</code></pre>
<p>You can also specify the <code>childViewOptions</code> as a function, if you need to
calculate the values to return at runtime. The model will be passed into
the function should you need access to it when calculating
<code>childViewOptions</code>. The function must return an object, and the attributes
of the object will be copied to the <code>childView</code> instance&#39;s options.</p>
<pre><code class="lang-js">CollectionView = Backbone.Marionette.CollectionView({
  childViewOptions: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(model, index)</span> </span>{
    <span class="hljs-comment">// do some calculations based on the model</span>
    <span class="hljs-keyword">return</span> {
      foo: <span class="hljs-string">"bar"</span>,
      childIndex: index
    }
  }
});
</code></pre>
<h3><a name="collectionviews-childvieweventprefix" class="anchor" href="#collectionviews-childvieweventprefix"><span class="header-link"></span></a>CollectionView&#39;s <code>childViewEventPrefix</code></h3><p>You can customize the event prefix for events that are forwarded
through the collection view. To do this, set the <code>childViewEventPrefix</code>
on the collection view.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> CV = Marionette.CollectionView.extend({
  childViewEventPrefix: <span class="hljs-string">"some:prefix"</span>
});

<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> CV({
  collection: myCol
});

c.on(<span class="hljs-string">"some:prefix:render"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  <span class="hljs-comment">// child view was rendered</span>
});

c.render();
</code></pre>
<p>The <code>childViewEventPrefix</code> can be provided in the view definition or
in the constructor function call, to get a view instance.</p>
<h3><a name="collectionviews-childevents" class="anchor" href="#collectionviews-childevents"><span class="header-link"></span></a>CollectionView&#39;s <code>childEvents</code></h3><p>You can specify a <code>childEvents</code> hash or method which allows you to capture all bubbling childEvents without having to manually set bindings. The keys of the hash can either be a function or a string that is the name of a method on the collection view.</p>
<pre><code class="lang-js">childEvents: {
  <span class="hljs-string">"render"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"a childView has been rendered"</span>);
  },
  <span class="hljs-string">"onChildDestroy"</span>: <span class="hljs-string">"someFn"</span> <span class="hljs-comment">// where the collection view has a method `someFn`</span>
}
</code></pre>
<p>You can also use a method for <code>childEvents</code> that returns a hash.</p>
<pre><code class="lang-js">childEvents: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-string">"render"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"a childView has been rendered"</span>);
    }
  }
}
</code></pre>
<h3><a name="collectionviews-buildchildview" class="anchor" href="#collectionviews-buildchildview"><span class="header-link"></span></a>CollectionView&#39;s <code>buildChildView</code></h3><p>When a custom view instance needs to be created for the <code>childView</code> that
represents a child, override the <code>buildChildView</code> method. This method
takes three parameters and returns a view instance to be used as the
child view.</p>
<pre><code class="lang-js">buildChildView: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(child, ChildViewClass, childViewOptions)</span></span>{
  <span class="hljs-comment">// build the final list of options for the childView class</span>
  <span class="hljs-keyword">var</span> options = _.extend({model: child}, childViewOptions);
  <span class="hljs-comment">// create the child view instance</span>
  <span class="hljs-keyword">var</span> view = <span class="hljs-keyword">new</span> ChildViewClass(options);
  <span class="hljs-comment">// return it</span>
  <span class="hljs-keyword">return</span> view;
},
</code></pre>
<h3><a name="collectionviews-addchild" class="anchor" href="#collectionviews-addchild"><span class="header-link"></span></a>CollectionView&#39;s <code>addChild</code></h3><p>The <code>addChild</code> method is responsible for rendering the <code>childViews</code> and adding them to the HTML for the <code>collectionView</code> instance. It is also responsible for triggering the events per <code>ChildView</code>. In most cases you should not override this method. However if you do want to short circut this method, it can be accomplished via the following.</p>
<pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  addChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(child, ChildView, index)</span></span>{
    <span class="hljs-keyword">if</span> (child.shouldBeShown()) {
      Backbone.Marionette.CollectionView.prototype.addChild.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }
  }
});
</code></pre>
<h2><a name="collectionviews-emptyview" class="anchor" href="#collectionviews-emptyview"><span class="header-link"></span></a>CollectionView&#39;s <code>emptyView</code></h2><p>When a collection has no children, and you need to render a view other than
the list of childViews, you can specify an <code>emptyView</code> attribute on your
collection view.</p>
<pre><code class="lang-js">NoChildsView = Backbone.Marionette.ItemView.extend({
  template: <span class="hljs-string">"#show-no-children-message-template"</span>
});

Backbone.Marionette.CollectionView.extend({
  <span class="hljs-comment">// ...</span>

  emptyView: NoChildsView
});
</code></pre>
<h3><a name="collectionviews-getemptyview" class="anchor" href="#collectionviews-getemptyview"><span class="header-link"></span></a>CollectionView&#39;s <code>getEmptyView</code></h3><p>If you need the <code>emptyView</code>&#39;s class chosen dynamically, specify <code>getEmptyView</code>:</p>
<pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  <span class="hljs-comment">// ...</span>

  getEmptyView: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// custom logic</span>
    <span class="hljs-keyword">return</span> NoChildsView;
  }
</code></pre>
<p>This will render the <code>emptyView</code> and display the message that needs to
be displayed when there are no children.</p>
<p>If you want to control when the empty view is rendered, you can override
<code>isEmpty</code>:</p>
<pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  isEmpty: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(collection)</span> </span>{
    <span class="hljs-comment">// some logic to calculate if the view should be rendered as empty</span>
    <span class="hljs-keyword">return</span> someBoolean;
  }
});
</code></pre>
<h3><a name="collectionviews-emptyviewoptions" class="anchor" href="#collectionviews-emptyviewoptions"><span class="header-link"></span></a>CollectionView&#39;s <code>emptyViewOptions</code></h3><p>Similar to <code>childView</code> and <code>childViewOptions</code>, there is an <code>emptyViewOptions</code> property that will be passed to the <code>emptyView</code> constructor. It can be provided as an object literal or as a function.</p>
<pre><code class="lang-js">EmptyView = Backbone.Marionette.ItemView({
  initialize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options)</span></span>{
    <span class="hljs-built_in">console</span>.log(options.foo); <span class="hljs-comment">// =&gt; "bar"</span>
  }
});

CollectionView = Backbone.Marionette.CollectionView({
  emptyView: EmptyView,

  emptyViewOptions: {
    foo: <span class="hljs-string">"bar"</span>
  }
});
</code></pre>
<h2><a name="callback-methods" class="anchor" href="#callback-methods"><span class="header-link"></span></a>Callback Methods</h2><p>There are several callback methods that can be provided on a
<code>CollectionView</code>. If they are found, they will be called by the
view&#39;s base methods. These callback methods are intended to be
handled within the view definition directly.</p>
<h3><a name="onbeforerender-callback" class="anchor" href="#onbeforerender-callback"><span class="header-link"></span></a>onBeforeRender callback</h3><p>A <code>onBeforeRender</code> callback will be called just prior to rendering
the collection view.</p>
<pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onBeforeRender: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// do stuff here</span>
  }
});
</code></pre>
<h3><a name="onrender-callback" class="anchor" href="#onrender-callback"><span class="header-link"></span></a>onRender callback</h3><p>After the view has been rendered, a <code>onRender</code> method will be called.
You can implement this in your view to provide custom code for dealing
with the view&#39;s <code>el</code> after it has been rendered:</p>
<pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onRender: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// do stuff here</span>
  }
});
</code></pre>
<h3><a name="onbeforedestroy-callback" class="anchor" href="#onbeforedestroy-callback"><span class="header-link"></span></a>onBeforeDestroy callback</h3><p>This method is called just before destroying the view.</p>
<pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onBeforeDestroy: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// do stuff here</span>
  }
});
</code></pre>
<h3><a name="ondestroy-callback" class="anchor" href="#ondestroy-callback"><span class="header-link"></span></a>onDestroy callback</h3><p>This method is called just after destroying the view.</p>
<pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onDestroy: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// do stuff here</span>
  }
});
</code></pre>
<h3><a name="onbeforeaddchild-callback" class="anchor" href="#onbeforeaddchild-callback"><span class="header-link"></span></a>onBeforeAddChild callback</h3><p>This callback function allows you to know when a child / child view
instance is about to be added to the collection view. It provides access to
the view instance for the child that was added.</p>
<pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onBeforeAddChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childView)</span></span>{
    <span class="hljs-comment">// work with the childView instance, here</span>
  }
});
</code></pre>
<h3><a name="onaddchild-callback" class="anchor" href="#onaddchild-callback"><span class="header-link"></span></a>onAddChild callback</h3><p>This callback function allows you to know when a child / child view
instance has been added to the collection view. It provides access to
the view instance for the child that was added.</p>
<pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onAddChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childView)</span></span>{
    <span class="hljs-comment">// work with the childView instance, here</span>
  }
});
</code></pre>
<h3><a name="onbeforeremovechild-callback" class="anchor" href="#onbeforeremovechild-callback"><span class="header-link"></span></a>onBeforeRemoveChild callback</h3><p>This callback function allows you to know when a <code>childView</code>
instance is about to be removed from the <code>collectionView</code>. It provides access to
the view instance for the child that was removed.</p>
<pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onBeforeRemoveChild: function(childView){
    // work with the childView instance, here
  }
});

### onRemoveChild callback

This callback function allows you to know when a child / childView
instance has been deleted or removed from the
collection.

```js
Backbone.Marionette.CollectionView.extend({
  onRemoveChild: function(childView){
    // work with the childView instance, here
  }
});
</code></pre>
<h2><a name="collectionview-events" class="anchor" href="#collectionview-events"><span class="header-link"></span></a>CollectionView Events</h2><p>There are several events that will be triggered during the life
of a collection view. Each of these events is called with the
<a href="./marionette.functions.md">Marionette.triggerMethod</a> function,
which calls a corresponding &quot;on{EventName}&quot; method on the
view instance (see <a href="#callback-methods">above</a>).</p>
<h3><a name="-before-render-event" class="anchor" href="#-before-render-event"><span class="header-link"></span></a>&quot;before:render&quot; event</h3><p>Triggers just prior to the view being rendered. Also triggered as
&quot;collection:before:render&quot; / <code>onCollectionBeforeRender</code>.</p>
<pre><code class="lang-js">MyView = Backbone.Marionette.CollectionView.extend({...});

<span class="hljs-keyword">var</span> myView = <span class="hljs-keyword">new</span> MyView();

myView.on(<span class="hljs-string">"before:render"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view is about to be rendered"</span>);
});

myView.render();
</code></pre>
<h3><a name="-render-event" class="anchor" href="#-render-event"><span class="header-link"></span></a>&quot;render&quot; event</h3><p>A &quot;collection:rendered&quot; / <code>onCollectionRendered</code> event will also be fired. This allows you to
add more than one callback to execute after the view is rendered,
and allows parent views and other parts of the application to
know that the view was rendered.</p>
<pre><code class="lang-js">MyView = Backbone.Marionette.CollectionView.extend({...});

<span class="hljs-keyword">var</span> myView = <span class="hljs-keyword">new</span> MyView();

myView.on(<span class="hljs-string">"render"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view was rendered!"</span>);
});

myView.on(<span class="hljs-string">"collection:rendered"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view was rendered!"</span>);
});

myView.render();
</code></pre>
<h3><a name="-before-destroy-event" class="anchor" href="#-before-destroy-event"><span class="header-link"></span></a>&quot;before:destroy&quot; event</h3><p>Triggered just before destroying the view. A &quot;before:destroy:collection&quot; /
<code>onBeforeDestroyCollection</code> event will also be fired</p>
<pre><code class="lang-js">MyView = Backbone.Marionette.CollectionView.extend({...});

<span class="hljs-keyword">var</span> myView = <span class="hljs-keyword">new</span> MyView();

myView.on(<span class="hljs-string">"before:destroy:collection"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view is about to be destroyed"</span>);
});

myView.destroy();
</code></pre>
<h3><a name="-destroy-destroy-collection-event" class="anchor" href="#-destroy-destroy-collection-event"><span class="header-link"></span></a>&quot;destroy&quot; / &quot;destroy:collection&quot; event</h3><p>Triggered just after destroying the view, both with corresponding
method calls.</p>
<pre><code class="lang-js">MyView = Backbone.Marionette.CollectionView.extend({...});

<span class="hljs-keyword">var</span> myView = <span class="hljs-keyword">new</span> MyView();

myView.on(<span class="hljs-string">"destroy:collection"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view is now destroyed"</span>);
});

myView.destroy();
</code></pre>
<h3><a name="-before-add-child-add-child-event" class="anchor" href="#-before-add-child-add-child-event"><span class="header-link"></span></a>&quot;before:add:child&quot; / &quot;add:child&quot; event</h3><p>The &quot;before:add:child&quot; event and corresponding <code>onBeforeAddChild</code>
method are triggered just after creating a new <code>childView</code> instance for
a child that was added to the collection, but before the
view is rendered and added to the DOM.</p>
<p>The &quot;add:child&quot; event and corresponding <code>onAddChild</code>
method are triggered after rendering the view and adding it to the
view&#39;s DOM element.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> MyCV = Marionette.CollectionView.extend({
  <span class="hljs-comment">// ...</span>

  onBeforeAddChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// ...</span>
  },

  onAddChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// ...</span>
  }
});

<span class="hljs-keyword">var</span> cv = <span class="hljs-keyword">new</span> MyCV({...});

cv.on(<span class="hljs-string">"before:add:child"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(viewInstance)</span></span>{
  <span class="hljs-comment">// ...</span>
});

cv.on(<span class="hljs-string">"add:child"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(viewInstance)</span></span>{
  <span class="hljs-comment">// ...</span>
});
</code></pre>
<h3><a name="-before-remove-child" class="anchor" href="#-before-remove-child"><span class="header-link"></span></a>&quot;before:remove:child&quot;</h3><p>This is triggered after the childView instance has been
removed from the collection, but before it has been destroyed.</p>
<pre><code class="lang-js">cv.on(<span class="hljs-string">"before:remove:child"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childView)</span></span>{
  <span class="hljs-comment">// ...</span>
});
</code></pre>
<h3><a name="-remove-child-event" class="anchor" href="#-remove-child-event"><span class="header-link"></span></a>&quot;remove:child&quot; event</h3><p>Triggered after a childView instance has been destroyed and
removed, when its child was deleted or removed from the
collection.</p>
<pre><code class="lang-js">cv.on(<span class="hljs-string">"remove:child"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(viewInstance)</span></span>{
  <span class="hljs-comment">// ...</span>
});
</code></pre>
<h3><a name="-childview-event-bubbling-from-child-views" class="anchor" href="#-childview-event-bubbling-from-child-views"><span class="header-link"></span></a>&quot;childview:*&quot; event bubbling from child views</h3><p>When a child view within a collection view triggers an
event, that event will bubble up through the parent
collection view with &quot;childview:&quot; prepended to the event
name.</p>
<p>That is, if a child view triggers &quot;do:something&quot;, the
parent collection view will then trigger &quot;childview:do:something&quot;.</p>
<pre><code class="lang-js"><span class="hljs-comment">// set up basic collection</span>
<span class="hljs-keyword">var</span> myModel = <span class="hljs-keyword">new</span> MyModel();
<span class="hljs-keyword">var</span> myCollection = <span class="hljs-keyword">new</span> MyCollection();
myCollection.add(myModel);

<span class="hljs-comment">// get the collection view in place</span>
colView = <span class="hljs-keyword">new</span> CollectionView({
  collection: myCollection
});
colView.render();

<span class="hljs-comment">// bind to the collection view's events that were bubbled</span>
<span class="hljs-comment">// from the child view</span>
colView.on(<span class="hljs-string">"childview:do:something"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childView, msg)</span></span>{
  alert(<span class="hljs-string">"I said, '"</span> + msg + <span class="hljs-string">"'"</span>);
});

<span class="hljs-comment">// hack, to get the child view and trigger from it</span>
<span class="hljs-keyword">var</span> childView = colView.children[myModel.cid];
childView.trigger(<span class="hljs-string">"do:something"</span>, <span class="hljs-string">"do something!"</span>);
</code></pre>
<p>The result of this will be an alert box that says
&quot;I said, &#39;do something!&#39;&quot;.</p>
<p>Also note that you would not normally grab a reference to
the child view the way this is showing. I&#39;m merely using
that hack as a way to demonstrate the event bubbling.
Normally, you would have your child view listening to DOM
events or model change events, and then triggering an event
of its own based on that.</p>
<h2><a name="collectionview-render" class="anchor" href="#collectionview-render"><span class="header-link"></span></a>CollectionView render</h2><p>The <code>render</code> method of the collection view is responsible for
rendering the entire collection. It loops through each of the
children in the collection and renders them individually as an
<code>childView</code>.</p>
<pre><code class="lang-js">MyCollectionView = Backbone.Marionette.CollectionView.extend({...});

<span class="hljs-keyword">new</span> MyCollectionView().render().done(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  <span class="hljs-comment">// all of the children are now rendered. do stuff here.</span>
});
</code></pre>
<h2><a name="collectionview-automatic-rendering" class="anchor" href="#collectionview-automatic-rendering"><span class="header-link"></span></a>CollectionView: Automatic Rendering</h2><p>The collection view binds to the &quot;add&quot;, &quot;remove&quot; and &quot;reset&quot; events of the
collection that is specified.</p>
<p>When the collection for the view is &quot;reset&quot;, the view will call <code>render</code> on
itself and re-render the entire collection.</p>
<p>When a model is added to the collection, the collection view will render that
one model in to the collection of child views.</p>
<p>When a model is removed from a collection (or destroyed / deleted), the collection
view will destroy and remove that model&#39;s child view.</p>
<h2><a name="collectionview-re-render-collection" class="anchor" href="#collectionview-re-render-collection"><span class="header-link"></span></a>CollectionView: Re-render Collection</h2><p>If you need to re-render the entire collection, you can call the
<code>view.render</code> method. This method takes care of destroying all of
the child views that may have previously been opened.</p>
<h2><a name="collectionviews-attachhtml" class="anchor" href="#collectionviews-attachhtml"><span class="header-link"></span></a>CollectionView&#39;s attachHtml</h2><p>By default the collection view will append the HTML of each ChildView
into the element buffer, and then call jQuery&#39;s <code>.append</code> once at the
end to move the HTML into the collection view&#39;s <code>el</code>.</p>
<p>You can override this by specifying an <code>attachHtml</code> method in your
view definition. This method takes three parameters and has no return
value.</p>
<pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({

    <span class="hljs-comment">// The default implementation:</span>
  attachHtml: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(collectionView, childView, index)</span></span>{
    <span class="hljs-keyword">if</span> (collectionView.isBuffering) {
      <span class="hljs-comment">// buffering happens on reset events and initial renders</span>
      <span class="hljs-comment">// in order to reduce the number of inserts into the</span>
      <span class="hljs-comment">// document, which are expensive.</span>
      collectionView.elBuffer.appendChild(childView.el);
    }
    <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// If we've already rendered the main collection, just</span>
      <span class="hljs-comment">// append the new children directly into the element.</span>
      collectionView.$el.append(childView.el);
    }
  },

  <span class="hljs-comment">// Called after all children have been appended into the elBuffer</span>
  appendHtml: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(collectionView, buffer)</span> </span>{
    collectionView.$el.append(buffer);
  },

  <span class="hljs-comment">// called on initialize and after appendHtml is called</span>
  initRenderBuffer: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>.elBuffer = <span class="hljs-built_in">document</span>.createDocumentFragment();
  }

});
</code></pre>
<p>The first parameter is the instance of the collection view that
will receive the HTML from the second parameter, the current child
view instance.</p>
<p>The third parameter, <code>index</code>, is the index of the
model that this <code>childView</code> instance represents, in the collection
that the model came from. This is useful for sorting a collection
and displaying the sorted list in the correct order on the screen.</p>
<p>Overrides of <code>attachHtml</code> that don&#39;t take into account the element
buffer will work fine, but won&#39;t take advantage of the 60x performance
increase the buffer provides.</p>
<h2><a name="collectionviews-children" class="anchor" href="#collectionviews-children"><span class="header-link"></span></a>CollectionView&#39;s children</h2><p>The CollectionView uses <a href="https://github.com/marionettejs/backbone.babysitter">Backbone.BabySitter</a>
to store and manage its child views. This allows you to easily access
the views within the collection view, iterate them, find them by
a given indexer such as the view&#39;s model or collection, and more.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> cv = <span class="hljs-keyword">new</span> Marionette.CollectionView({
  collection: someCollection
});

cv.render();


<span class="hljs-comment">// retrieve a view by model</span>
<span class="hljs-keyword">var</span> v = cv.children.findByModel(someModel);

<span class="hljs-comment">// iterate over all of the views and process them</span>
cv.children.each(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(view)</span></span>{

  <span class="hljs-comment">// process the `view` here</span>

});
</code></pre>
<p>For more information on the available features and functionality of
the <code>.children</code>, see the <a href="https://github.com/marionettejs/backbone.babysitter">Backbone.BabySitter documentation</a>.</p>
<h2><a name="collectionview-destroy" class="anchor" href="#collectionview-destroy"><span class="header-link"></span></a>CollectionView destroy</h2><p>CollectionView implements a <code>destroy</code> method, which is called by the
region managers automatically. As part of the implementation, the
following are performed:</p>
<ul>
<li>unbind all <code>listenTo</code> events</li>
<li>unbind all custom view events</li>
<li>unbind all DOM events</li>
<li>unbind all child views that were rendered</li>
<li>remove <code>this.el</code> from the DOM</li>
<li>call an <code>onDestroy</code> event on the view, if one is provided</li>
</ul>
<p>By providing an <code>onDestroy</code> event in your view definition, you can
run custom code for your view that is fired after your view has been
destroyed and cleaned up. This lets you handle any additional clean up
code without having to override the <code>destroy</code> method.</p>
<pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onDestroy: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// custom cleanup or destroying code, here</span>
  }
});
</code></pre>

      </div>
    </div>
  </body>
</html>
