<html>
  <head>
    <title>marionette.view - Marionette.js Docs</title>
    <link rel="stylesheet" href="../../styles/main.css">
  </head>
  <body>
    <div class="docs">
      <div class="docs__sidebar">
        <select>
          
            <option value="v0.1.0">v0.1.0</option>
          
            <option value="v0.10.0">v0.10.0</option>
          
            <option value="v0.10.1">v0.10.1</option>
          
            <option value="v0.10.2">v0.10.2</option>
          
            <option value="v0.2.0">v0.2.0</option>
          
            <option value="v0.2.1">v0.2.1</option>
          
            <option value="v0.2.2">v0.2.2</option>
          
            <option value="v0.2.3">v0.2.3</option>
          
            <option value="v0.2.4">v0.2.4</option>
          
            <option value="v0.2.5">v0.2.5</option>
          
            <option value="v0.2.6">v0.2.6</option>
          
            <option value="v0.3.0">v0.3.0</option>
          
            <option value="v0.3.1">v0.3.1</option>
          
            <option value="v0.4.0">v0.4.0</option>
          
            <option value="v0.4.1">v0.4.1</option>
          
            <option value="v0.4.1a">v0.4.1a</option>
          
            <option value="v0.4.2">v0.4.2</option>
          
            <option value="v0.4.3">v0.4.3</option>
          
            <option value="v0.4.4">v0.4.4</option>
          
            <option value="v0.4.5">v0.4.5</option>
          
            <option value="v0.4.6">v0.4.6</option>
          
            <option value="v0.4.7">v0.4.7</option>
          
            <option value="v0.4.8">v0.4.8</option>
          
            <option value="v0.5.0">v0.5.0</option>
          
            <option value="v0.5.1">v0.5.1</option>
          
            <option value="v0.5.2">v0.5.2</option>
          
            <option value="v0.6.0">v0.6.0</option>
          
            <option value="v0.6.1">v0.6.1</option>
          
            <option value="v0.6.2">v0.6.2</option>
          
            <option value="v0.6.3">v0.6.3</option>
          
            <option value="v0.7.0">v0.7.0</option>
          
            <option value="v0.7.1">v0.7.1</option>
          
            <option value="v0.7.2">v0.7.2</option>
          
            <option value="v0.7.3">v0.7.3</option>
          
            <option value="v0.7.4">v0.7.4</option>
          
            <option value="v0.7.5">v0.7.5</option>
          
            <option value="v0.7.6">v0.7.6</option>
          
            <option value="v0.8.0">v0.8.0</option>
          
            <option value="v0.8.1">v0.8.1</option>
          
            <option value="v0.8.2">v0.8.2</option>
          
            <option value="v0.8.3">v0.8.3</option>
          
            <option value="v0.8.4">v0.8.4</option>
          
            <option value="v0.9.0">v0.9.0</option>
          
            <option value="v0.9.1">v0.9.1</option>
          
            <option value="v0.9.10">v0.9.10</option>
          
            <option value="v0.9.11">v0.9.11</option>
          
            <option value="v0.9.12">v0.9.12</option>
          
            <option value="v0.9.13">v0.9.13</option>
          
            <option value="v0.9.2">v0.9.2</option>
          
            <option value="v0.9.3">v0.9.3</option>
          
            <option value="v0.9.4">v0.9.4</option>
          
            <option value="v0.9.5">v0.9.5</option>
          
            <option value="v0.9.6">v0.9.6</option>
          
            <option value="v0.9.7">v0.9.7</option>
          
            <option value="v0.9.8">v0.9.8</option>
          
            <option value="v0.9.9">v0.9.9</option>
          
            <option value="v1.0.0">v1.0.0</option>
          
            <option value="v1.0.0-beta1">v1.0.0-beta1</option>
          
            <option value="v1.0.0-beta2">v1.0.0-beta2</option>
          
            <option value="v1.0.0-beta3">v1.0.0-beta3</option>
          
            <option value="v1.0.0-beta4">v1.0.0-beta4</option>
          
            <option value="v1.0.0-beta5">v1.0.0-beta5</option>
          
            <option value="v1.0.0-beta6">v1.0.0-beta6</option>
          
            <option value="v1.0.0-rc1">v1.0.0-rc1</option>
          
            <option value="v1.0.0-rc2">v1.0.0-rc2</option>
          
            <option value="v1.0.0-rc3">v1.0.0-rc3</option>
          
            <option value="v1.0.0-rc4">v1.0.0-rc4</option>
          
            <option value="v1.0.0-rc5">v1.0.0-rc5</option>
          
            <option value="v1.0.0-rc6">v1.0.0-rc6</option>
          
            <option value="v1.0.1">v1.0.1</option>
          
            <option value="v1.0.2">v1.0.2</option>
          
            <option value="v1.0.3">v1.0.3</option>
          
            <option value="v1.0.4">v1.0.4</option>
          
            <option value="v1.1.0">v1.1.0</option>
          
            <option value="v1.2.0">v1.2.0</option>
          
            <option value="v1.2.1">v1.2.1</option>
          
            <option value="v1.2.2">v1.2.2</option>
          
            <option value="v1.2.3">v1.2.3</option>
          
            <option value="v1.3.0">v1.3.0</option>
          
            <option value="v1.4.0">v1.4.0</option>
          
            <option value="v1.4.0beta">v1.4.0beta</option>
          
            <option value="v1.4.1">v1.4.1</option>
          
            <option value="v1.5.0">v1.5.0</option>
          
            <option value="v1.5.1">v1.5.1</option>
          
            <option value="v1.6.0">v1.6.0</option>
          
            <option value="v1.6.1">v1.6.1</option>
          
            <option value="v1.6.2">v1.6.2</option>
          
            <option value="v1.6.3">v1.6.3</option>
          
            <option value="v1.6.4">v1.6.4</option>
          
            <option value="v1.7">v1.7</option>
          
            <option value="v1.7.1">v1.7.1</option>
          
            <option value="v1.7.2">v1.7.2</option>
          
            <option value="v1.7.3">v1.7.3</option>
          
            <option value="v1.7.4">v1.7.4</option>
          
            <option value="v1.8.0">v1.8.0</option>
          
            <option value="v1.8.1">v1.8.1</option>
          
            <option value="v1.8.2">v1.8.2</option>
          
            <option value="v1.8.3">v1.8.3</option>
          
            <option value="v1.8.4">v1.8.4</option>
          
            <option value="v1.8.5">v1.8.5</option>
          
            <option value="v1.8.6">v1.8.6</option>
          
            <option value="v1.8.7">v1.8.7</option>
          
            <option value="v1.8.8">v1.8.8</option>
          
            <option value="v2.0.0">v2.0.0</option>
          
            <option value="v2.0.0-pre.1">v2.0.0-pre.1</option>
          
            <option value="v2.0.0-pre.2">v2.0.0-pre.2</option>
          
            <option value="v2.0.1">v2.0.1</option>
          
            <option value="v2.0.2">v2.0.2</option>
          
            <option value="v2.0.3">v2.0.3</option>
          
            <option value="v2.1.0">v2.1.0</option>
          
            <option value="v2.1.0-pre">v2.1.0-pre</option>
          
            <option value="v2.2.0">v2.2.0</option>
          
            <option value="v2.2.0-pre">v2.2.0-pre</option>
          
            <option value="v2.2.0-pre.2">v2.2.0-pre.2</option>
          
            <option value="v2.2.1">v2.2.1</option>
          
        </select>
        <nav>
          
            <a href="marionette.application.html">marionette.application</a>
          
            <a href="marionette.application.module.html">marionette.application.module</a>
          
            <a href="marionette.approuter.html">marionette.approuter</a>
          
            <a href="marionette.behavior.html">marionette.behavior</a>
          
            <a href="marionette.behaviors.html">marionette.behaviors</a>
          
            <a href="marionette.callbacks.html">marionette.callbacks</a>
          
            <a href="marionette.collectionview.html">marionette.collectionview</a>
          
            <a href="marionette.compositeview.html">marionette.compositeview</a>
          
            <a href="marionette.configuration.html">marionette.configuration</a>
          
            <a href="marionette.controller.html">marionette.controller</a>
          
            <a href="marionette.functions.html">marionette.functions</a>
          
            <a href="marionette.itemview.html">marionette.itemview</a>
          
            <a href="marionette.layout.html">marionette.layout</a>
          
            <a href="marionette.region.html">marionette.region</a>
          
            <a href="marionette.regionmanager.html">marionette.regionmanager</a>
          
            <a href="marionette.renderer.html">marionette.renderer</a>
          
            <a href="marionette.templatecache.html">marionette.templatecache</a>
          
            <a href="marionette.view.html">marionette.view</a>
          
        </nav>
      </div>
      <div class="docs__content">
        <pre>{
  &quot;tag&quot;: &quot;v1.8.2&quot;,
  &quot;basename&quot;: &quot;marionette.view&quot;,
  &quot;filenane&quot;: &quot;marionette.view.md&quot;,
  &quot;pathname&quot;: &quot;/Users/sam/Desktop/repos/marionettejs.com/.grunt/compileDocs/1412653309300/v1.8.2&quot;,
  &quot;contents&quot;: &quot;&lt;h1&gt;&lt;a name=\&quot;marionette-view\&quot; class=\&quot;anchor\&quot; href=\&quot;#marionette-view\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Marionette.View&lt;/h1&gt;&lt;p&gt;Marionette has a base &lt;code&gt;Marionette.View&lt;/code&gt; type that other views extend from.\nThis base view provides some common and core functionality for\nother views to take advantage of.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;Marionette.View&lt;/code&gt; type is not intended to be\nused directly. It exists as a base view for other view types\nto be extended from, and to provide a common location for\nbehaviors that are shared across all views.&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;documentation-index\&quot; class=\&quot;anchor\&quot; href=\&quot;#documentation-index\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Documentation Index&lt;/h2&gt;&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&quot;#binding-to-view-events\&quot;&gt;Binding To View Events&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#view-onshow\&quot;&gt;View onShow&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#view-close\&quot;&gt;View close&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#view-onbeforeclose\&quot;&gt;View onBeforeClose&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#view-domrefresh--ondomrefresh-event\&quot;&gt;View &amp;quot;dom:refresh&amp;quot; / onDomRefresh event&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#viewtriggers\&quot;&gt;View.triggers&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#viewevents\&quot;&gt;View.events&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#viewmodelevents-and-viewcollectionevents\&quot;&gt;View.modelEvents and View.collectionEvents&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#viewserializedata\&quot;&gt;View.serializeData&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#viewbinduielements\&quot;&gt;View.bindUIElements&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#viewtemplatehelpers\&quot;&gt;View.templateHelpers&lt;/a&gt;&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&quot;#basic-example\&quot;&gt;Basic Example&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#accessing-data-within-the-helpers\&quot;&gt;Accessing Data Within The Helpers&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#object-or-function-as-templatehelpers\&quot;&gt;Object Or Function As &lt;code&gt;templateHelpers&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&quot;#change-which-template-is-rendered-for-a-view\&quot;&gt;Change Which Template Is Rendered For A View&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2&gt;&lt;a name=\&quot;binding-to-view-events\&quot; class=\&quot;anchor\&quot; href=\&quot;#binding-to-view-events\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Binding To View Events&lt;/h2&gt;&lt;p&gt;Marionette.View extends &lt;code&gt;Backbone.View&lt;/code&gt;. It is recommended that you use\nthe &lt;code&gt;listenTo&lt;/code&gt; method to bind model, collection, or other events from Backbone\nand Marionette objects.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyView = Backbone.Marionette.ItemView.extend({\n  initialize: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;.listenTo(&lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;.model, &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;change:foo\&quot;&lt;/span&gt;, &lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;.modelChanged);\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;.listenTo(&lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;.collection, &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;add\&quot;&lt;/span&gt;, &lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;.modelAdded);\n  },\n\n  modelChanged: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(model, value)&lt;/span&gt;&lt;/span&gt;{\n  },\n\n  modelAdded: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(model)&lt;/span&gt;&lt;/span&gt;{\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The context (&lt;code&gt;this&lt;/code&gt;) will automatically be set to the view. You can\noptionally set the context by using &lt;code&gt;_.bind&lt;/code&gt;.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;&lt;span class=\&quot;hljs-comment\&quot;&gt;// Force the context of the \&quot;reconcileCollection\&quot; callback method to be the collection&lt;/span&gt;\n&lt;span class=\&quot;hljs-comment\&quot;&gt;// itself, for this event handler only (does not affect any other use of the&lt;/span&gt;\n&lt;span class=\&quot;hljs-comment\&quot;&gt;// \&quot;reconcileCollection\&quot; method)&lt;/span&gt;\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;.listenTo(&lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;.collection, &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;add\&quot;&lt;/span&gt;, _.bind(&lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;.reconcileCollection, &lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;.collection));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&lt;a name=\&quot;view-onshow\&quot; class=\&quot;anchor\&quot; href=\&quot;#view-onshow\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;View onShow&lt;/h2&gt;&lt;ul&gt;\n&lt;li&gt;&amp;quot;show&amp;quot; / &lt;code&gt;onShow&lt;/code&gt; - Called on the view instance when the view has been rendered and displayed.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;This event can be used to react to when a view has been shown via a &lt;a href=\&quot;marionette.region.md\&quot;&gt;region&lt;/a&gt;.\nAll &lt;code&gt;views&lt;/code&gt; that inherit from the base &lt;code&gt;Marionette.View&lt;/code&gt; class have this functionality. &lt;code&gt;ItemView&lt;/code&gt;, &amp;#39;CollectionView&amp;#39;, &amp;#39;CompositeView&amp;#39;, &amp;#39;Layout&amp;#39;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.ItemView.extend({\n  onShow: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// react to when a view has been shown&lt;/span&gt;\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;A common use case for the &lt;code&gt;onShow&lt;/code&gt; method is to use it to add children views.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; LayoutView = Backbone.Marionette.Layout.extend({\n   regions: {\n     Header: &lt;span class=\&quot;hljs-string\&quot;&gt;&#x27;header&#x27;&lt;/span&gt;,\n     Section: &lt;span class=\&quot;hljs-string\&quot;&gt;&#x27;section&#x27;&lt;/span&gt;\n   },\n   onShow: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n      &lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;.Header.show(&lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; Header());\n      &lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;.Section.show(&lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; Section());\n   }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&lt;a name=\&quot;view-close\&quot; class=\&quot;anchor\&quot; href=\&quot;#view-close\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;View close&lt;/h2&gt;&lt;p&gt;View implements a &lt;code&gt;close&lt;/code&gt; method, which is called by the region\nmanagers automatically. As part of the implementation, the following\nare performed:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;call an &lt;code&gt;onBeforeClose&lt;/code&gt; event on the view, if one is provided&lt;/li&gt;\n&lt;li&gt;call an &lt;code&gt;onClose&lt;/code&gt; event on the view, if one is provided&lt;/li&gt;\n&lt;li&gt;unbind all custom view events&lt;/li&gt;\n&lt;li&gt;unbind all DOM events&lt;/li&gt;\n&lt;li&gt;remove &lt;code&gt;this.el&lt;/code&gt; from the DOM&lt;/li&gt;\n&lt;li&gt;unbind all &lt;code&gt;listenTo&lt;/code&gt; events&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;By providing an &lt;code&gt;onClose&lt;/code&gt; method in your view definition, you can\nrun custom code for your view that is fired after your view has been\nclosed and cleaned up. The &lt;code&gt;onClose&lt;/code&gt; method will be passed any arguments\nthat &lt;code&gt;close&lt;/code&gt; was invoked with. This lets you handle any additional clean\nup code without having to override the &lt;code&gt;close&lt;/code&gt; method.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyView = Backbone.Marionette.ItemView.extend({\n  onClose: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(arg1, arg2)&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// custom cleanup or closing code, here&lt;/span&gt;\n  }\n});\n\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; v = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MyView();\nv.close(arg1, arg2);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&lt;a name=\&quot;view-onbeforeclose\&quot; class=\&quot;anchor\&quot; href=\&quot;#view-onbeforeclose\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;View onBeforeClose&lt;/h2&gt;&lt;p&gt;When closing a view, an &lt;code&gt;onBeforeClose&lt;/code&gt; method will be called, if it\nhas been provided. It will be passed any arguments that &lt;code&gt;close&lt;/code&gt; was\ninvoked with. If this method returns &lt;code&gt;false&lt;/code&gt;, the view will not\nbe closed. Any other return value (including null or undefined) will\nallow the view to be closed.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyView = Marionette.View.extend({\n\n  onBeforeClose: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// prevent the view from being closed&lt;/span&gt;\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; &lt;span class=\&quot;hljs-literal\&quot;&gt;false&lt;/span&gt;;\n  }\n\n});\n\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; v = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MyView();\n\nv.close(); &lt;span class=\&quot;hljs-comment\&quot;&gt;// view will remain open&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;view-dom-refresh-ondomrefresh-event\&quot; class=\&quot;anchor\&quot; href=\&quot;#view-dom-refresh-ondomrefresh-event\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;View &amp;quot;dom:refresh&amp;quot; / onDomRefresh event&lt;/h3&gt;&lt;p&gt;Triggered after the view has been rendered, has been shown in the DOM via a Marionette.Region, and has been\nre-rendered.&lt;/p&gt;\n&lt;p&gt;This event / callback is useful for\n&lt;a href=\&quot;http://lostechies.com/derickbailey/2012/02/20/using-jquery-plugins-and-ui-controls-with-backbone/\&quot;&gt;DOM-dependent UI plugins&lt;/a&gt; such as\n&lt;a href=\&quot;http://jqueryui.com/\&quot;&gt;jQueryUI&lt;/a&gt; or &lt;a href=\&quot;http://kendoui.com\&quot;&gt;KendoUI&lt;/a&gt;.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.ItemView.extend({\n  onDomRefresh: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// manipulate the &#x60;el&#x60; here. it&#x27;s already&lt;/span&gt;\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// been rendered, and is full of the view&#x27;s&lt;/span&gt;\n    &lt;span class=\&quot;hljs-comment\&quot;&gt;// HTML, ready to go.&lt;/span&gt;\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;For more information about integration Marionette w/ KendoUI (also applicable to jQueryUI and other UI\nwidget suites), see &lt;a href=\&quot;http://www.kendoui.com/blogs/teamblog/posts/12-11-26/backbone_and_kendo_ui_a_beautiful_combination.aspx\&quot;&gt;this blog post on KendoUI + Backbone&lt;/a&gt;.&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;view-events\&quot; class=\&quot;anchor\&quot; href=\&quot;#view-events\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;View.events&lt;/h2&gt;&lt;p&gt;Since Views extend from backbone&#x60;s view class, you gain the benefits of the &lt;a href=\&quot;http://backbonejs.org/#View-delegateEvents\&quot;&gt;events hash&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Some preprocessing sugar is added on top to add the ability to cross utilize the &lt;code&gt;ui&lt;/code&gt; hash.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyView = Backbone.Marionette.ItemView.extend({\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// ...&lt;/span&gt;\n\n  ui: {\n    &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;cat\&quot;&lt;/span&gt;: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;.dog\&quot;&lt;/span&gt;\n  },\n\n  events: {\n    &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;click @ui.cat\&quot;&lt;/span&gt;: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;bark\&quot;&lt;/span&gt; &lt;span class=\&quot;hljs-comment\&quot;&gt;//is the same as \&quot;click .dog\&quot;:&lt;/span&gt;\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&lt;a name=\&quot;view-triggers\&quot; class=\&quot;anchor\&quot; href=\&quot;#view-triggers\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;View.triggers&lt;/h2&gt;&lt;p&gt;Views can define a set of &lt;code&gt;triggers&lt;/code&gt; as a hash, which will\nconvert a DOM event into a &lt;code&gt;view.triggerMethod&lt;/code&gt; call.&lt;/p&gt;\n&lt;p&gt;The left side of the hash is a standard Backbone.View DOM\nevent configuration, while the right side of the hash is the\nview event that you want to trigger from the view.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyView = Backbone.Marionette.ItemView.extend({\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// ...&lt;/span&gt;\n\n  triggers: {\n    &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;click .do-something\&quot;&lt;/span&gt;: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;something:do:it\&quot;&lt;/span&gt;\n  }\n});\n\nview = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MyView();\nview.render();\n\nview.on(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;something:do:it\&quot;&lt;/span&gt;, &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(args)&lt;/span&gt;&lt;/span&gt;{\n  alert(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;I DID IT!\&quot;&lt;/span&gt;);\n});\n\n&lt;span class=\&quot;hljs-comment\&quot;&gt;// \&quot;click\&quot; the &#x27;do-something&#x27; DOM element to&lt;/span&gt;\n&lt;span class=\&quot;hljs-comment\&quot;&gt;// demonstrate the DOM event conversion&lt;/span&gt;\nview.$(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;.do-something\&quot;&lt;/span&gt;).trigger(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;click\&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The result of this is an alert box that says, &amp;quot;I DID IT!&amp;quot;&lt;/p&gt;\n&lt;p&gt;By default all triggers are stopped with &lt;code&gt;preventDefault&lt;/code&gt; and &lt;code&gt;stopPropagation&lt;/code&gt; methods. But you can manually configure the triggers using hash instead of event name. Example below triggers an event and prevents default browser behaviour using &lt;code&gt;preventDefault&lt;/code&gt; method.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CompositeView.extend({\n  triggers: {\n    &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;click .do-something\&quot;&lt;/span&gt;: {\n      event: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;something:do:it\&quot;&lt;/span&gt;,\n      preventDefault: &lt;span class=\&quot;hljs-literal\&quot;&gt;true&lt;/span&gt;, &lt;span class=\&quot;hljs-comment\&quot;&gt;// this param is optional and will default to true&lt;/span&gt;\n      stopPropagation: &lt;span class=\&quot;hljs-literal\&quot;&gt;false&lt;/span&gt;\n    }\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You can also specify the &lt;code&gt;triggers&lt;/code&gt; as a function that\nreturns a hash of trigger configurations&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CompositeView.extend({\n  triggers: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; {\n      &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;click .that-thing\&quot;&lt;/span&gt;: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;that:i:sent:you\&quot;&lt;/span&gt;\n    };\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Trigger keys can be configured to cross utilize the &lt;code&gt;ui&lt;/code&gt; hash.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.ItemView.extend({\n  ui: {\n     &lt;span class=\&quot;hljs-string\&quot;&gt;&#x27;monkey&#x27;&lt;/span&gt;: &lt;span class=\&quot;hljs-string\&quot;&gt;&#x27;.guybrush&#x27;&lt;/span&gt;\n  },\n  triggers: {\n    &lt;span class=\&quot;hljs-string\&quot;&gt;&#x27;click @ui.monkey&#x27;&lt;/span&gt;: &lt;span class=\&quot;hljs-string\&quot;&gt;&#x27;see:LeChuck&#x27;&lt;/span&gt; &lt;span class=\&quot;hljs-comment\&quot;&gt;// equivalent of \&quot;click .guybrush\&quot;&lt;/span&gt;\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Triggers work with all View types that extend from the base\nMarionette.View.&lt;/p&gt;\n&lt;h3&gt;&lt;a name=\&quot;trigger-handler-arguments\&quot; class=\&quot;anchor\&quot; href=\&quot;#trigger-handler-arguments\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Trigger Handler Arguments&lt;/h3&gt;&lt;p&gt;A &lt;code&gt;trigger&lt;/code&gt; event handler will receive a single argument that\nincludes the following:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;view&lt;/li&gt;\n&lt;li&gt;model&lt;/li&gt;\n&lt;li&gt;collection&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;These properties match the &lt;code&gt;view&lt;/code&gt;, &lt;code&gt;model&lt;/code&gt;, and &lt;code&gt;collection&lt;/code&gt; properties of the view that triggered the event.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyView = Backbone.Marionette.ItemView.extend({\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// ...&lt;/span&gt;\n\n  triggers: {\n    &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;click .do-something\&quot;&lt;/span&gt;: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;some:event\&quot;&lt;/span&gt;\n  }\n});\n\nview = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MyView();\n\nview.on(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;some:event\&quot;&lt;/span&gt;, &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;(args)&lt;/span&gt;&lt;/span&gt;{\n  args.view; &lt;span class=\&quot;hljs-comment\&quot;&gt;// =&amp;gt; the view instance that triggered the event&lt;/span&gt;\n  args.model; &lt;span class=\&quot;hljs-comment\&quot;&gt;// =&amp;gt; the view.model, if one was set on the view&lt;/span&gt;\n  args.collection; &lt;span class=\&quot;hljs-comment\&quot;&gt;// =&amp;gt; the view.collection, if one was set on the view&lt;/span&gt;\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Having access to these allows more flexibility in handling events from\nmultiple views. For example, a tab control or expand/collapse widget such\nas a panel bar could trigger the same event from many different views\nand be handled with a single function.&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;view-modelevents-and-view-collectionevents\&quot; class=\&quot;anchor\&quot; href=\&quot;#view-modelevents-and-view-collectionevents\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;View.modelEvents and View.collectionEvents&lt;/h2&gt;&lt;p&gt;Similar to the &lt;code&gt;events&lt;/code&gt; hash, views can specify a configuration\nhash for collections and models. The left side is the event on\nthe model or collection, and the right side is the name of the\nmethod on the view.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CompositeView.extend({\n\n  modelEvents: {\n    &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;change:name\&quot;&lt;/span&gt;: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;nameChanged\&quot;&lt;/span&gt; &lt;span class=\&quot;hljs-comment\&quot;&gt;// equivalent to view.listenTo(view.model, \&quot;change:name\&quot;, view.nameChanged, view)&lt;/span&gt;\n  },\n\n  collectionEvents: {\n    &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;add\&quot;&lt;/span&gt;: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;itemAdded\&quot;&lt;/span&gt; &lt;span class=\&quot;hljs-comment\&quot;&gt;// equivalent to view.listenTo(view.collection, \&quot;add\&quot;, view.itemAdded, view)&lt;/span&gt;\n  },\n\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// ... event handler methods&lt;/span&gt;\n  nameChanged: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{ &lt;span class=\&quot;hljs-comment\&quot;&gt;/* ... */&lt;/span&gt; },\n  itemAdded: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{ &lt;span class=\&quot;hljs-comment\&quot;&gt;/* ... */&lt;/span&gt; },\n\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;These will use the memory safe &lt;code&gt;listenTo&lt;/code&gt;, and will set the context\n(the value of &lt;code&gt;this&lt;/code&gt;) in the handler to be the view. Events are\nbound at the time of instantiation, and an exception will be thrown\nif the handlers on the view do not exist.&lt;/p&gt;\n&lt;p&gt;The &lt;code&gt;modelEvents&lt;/code&gt; and &lt;code&gt;collectionEvents&lt;/code&gt; will be bound and\nunbound with the Backbone.View &lt;code&gt;delegateEvents&lt;/code&gt; and &lt;code&gt;undelegateEvents&lt;/code&gt;\nmethod calls. This allows the view to be re-used and have\nthe model and collection events re-bound.&lt;/p&gt;\n&lt;h3&gt;&lt;a name=\&quot;multiple-callbacks\&quot; class=\&quot;anchor\&quot; href=\&quot;#multiple-callbacks\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Multiple Callbacks&lt;/h3&gt;&lt;p&gt;Multiple callback functions can be specified by separating them with a\nspace.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CompositeView.extend({\n\n  modelEvents: {\n    &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;change:name\&quot;&lt;/span&gt;: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;nameChanged thatThing\&quot;&lt;/span&gt;\n  },\n\n  nameChanged: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{ },\n\n  thatThing: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{ },\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This works in both &lt;code&gt;modelEvents&lt;/code&gt; and &lt;code&gt;collectionEvents&lt;/code&gt;.&lt;/p&gt;\n&lt;h3&gt;&lt;a name=\&quot;callbacks-as-function\&quot; class=\&quot;anchor\&quot; href=\&quot;#callbacks-as-function\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Callbacks As Function&lt;/h3&gt;&lt;p&gt;A single function can be declared directly in-line instead of specifying a\ncallback via a string method name.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CompositeView.extend({\n\n  modelEvents: {\n    &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;change:name\&quot;&lt;/span&gt;: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n      &lt;span class=\&quot;hljs-comment\&quot;&gt;// handle the name changed event here&lt;/span&gt;\n    }\n  }\n\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This works for both &lt;code&gt;modelEvents&lt;/code&gt; and &lt;code&gt;collectionEvents&lt;/code&gt;.&lt;/p&gt;\n&lt;h3&gt;&lt;a name=\&quot;event-configuration-as-function\&quot; class=\&quot;anchor\&quot; href=\&quot;#event-configuration-as-function\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Event Configuration As Function&lt;/h3&gt;&lt;p&gt;A function can be used to declare the event configuration as long as\nthat function returns a hash that fits the above configuration options.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.CompositeView.extend({\n\n  modelEvents: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; { &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;change:name\&quot;&lt;/span&gt;: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;someFunc\&quot;&lt;/span&gt; };\n  }\n\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This works for both &lt;code&gt;modelEvents&lt;/code&gt; and &lt;code&gt;collectionEvents&lt;/code&gt;.&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;view-serializedata\&quot; class=\&quot;anchor\&quot; href=\&quot;#view-serializedata\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;View.serializeData&lt;/h2&gt;&lt;p&gt;The &lt;code&gt;serializeData&lt;/code&gt; method will serialize a view&amp;#39;s model or\ncollection - with precedence given to collections. That is,\nif you have both a collection and a model in a view, calling\nthe &lt;code&gt;serializeData&lt;/code&gt; method will return the serialized\ncollection.&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;view-binduielements\&quot; class=\&quot;anchor\&quot; href=\&quot;#view-binduielements\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;View.bindUIElements&lt;/h2&gt;&lt;p&gt;In several cases you need to access ui elements inside the view\nto retrieve their data or manipulate them. For example you have a\ncertain div element you need to show/hide based on some state,\nor other ui element that you wish to set a css class to it.\nInstead of having jQuery selectors hanging around in the view&amp;#39;s code\nyou can define a &lt;code&gt;ui&lt;/code&gt; hash that contains a mapping between the\nui element&amp;#39;s name and its jQuery selector. Afterwards you can simply\naccess it via &lt;code&gt;this.ui.elementName&lt;/code&gt;.\nSee ItemView documentation for examples.&lt;/p&gt;\n&lt;p&gt;This functionality is provided via the &lt;code&gt;bindUIElements&lt;/code&gt; method.\nSince View doesn&amp;#39;t implement the render method, then if you directly extend\nfrom View you will need to invoke this method from your render method.\nIn ItemView and CompositeView this is already taken care of.&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;view-templatehelpers\&quot; class=\&quot;anchor\&quot; href=\&quot;#view-templatehelpers\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;View.templateHelpers&lt;/h2&gt;&lt;p&gt;There are times when a view&amp;#39;s template needs to have some\nlogic in it and the view engine itself will not provide an\neasy way to accomplish this. For example, Underscore templates\ndo not provide a helper method mechanism while Handlebars\ntemplates do.&lt;/p&gt;\n&lt;p&gt;A &lt;code&gt;templateHelpers&lt;/code&gt; attribute can be applied to any View object that\nrenders a template. When this attribute is present its contents\nwill be mixed in to the data object that comes back from the\n&lt;code&gt;serializeData&lt;/code&gt; method. This will allow you to create helper methods\nthat can be called from within your templates.&lt;/p&gt;\n&lt;h3&gt;&lt;a name=\&quot;basic-example\&quot; class=\&quot;anchor\&quot; href=\&quot;#basic-example\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Basic Example&lt;/h3&gt;&lt;pre&gt;&lt;code class=\&quot;lang-html\&quot;&gt;&lt;span class=\&quot;hljs-tag\&quot;&gt;&amp;lt;&lt;span class=\&quot;hljs-title\&quot;&gt;script&lt;/span&gt; &lt;span class=\&quot;hljs-attribute\&quot;&gt;id&lt;/span&gt;=&lt;span class=\&quot;hljs-value\&quot;&gt;\&quot;my-template\&quot;&lt;/span&gt; &lt;span class=\&quot;hljs-attribute\&quot;&gt;type&lt;/span&gt;=&lt;span class=\&quot;hljs-value\&quot;&gt;\&quot;text/html\&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=\&quot;javascript\&quot;&gt;\n  I think that &amp;lt;%= showMessage() %&amp;gt;\n&lt;/span&gt;&lt;span class=\&quot;hljs-tag\&quot;&gt;&amp;lt;/&lt;span class=\&quot;hljs-title\&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyView = Backbone.Marionette.ItemView.extend({\n  template: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;#my-template\&quot;&lt;/span&gt;,\n\n  templateHelpers: {\n    showMessage: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n      &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; &lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;.name + &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot; is the coolest!\&quot;&lt;/span&gt;\n    }\n  }\n\n});\n\nmodel = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; Backbone.Model({name: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;Backbone.Marionette\&quot;&lt;/span&gt;});\nview = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MyView({\n  model: model\n});\n\nview.render(); &lt;span class=\&quot;hljs-comment\&quot;&gt;//=&amp;gt; \&quot;I think that Backbone.Marionette is the coolest!\&quot;;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The &lt;code&gt;templateHelpers&lt;/code&gt; can also be provided as a constructor parameter\nfor any Marionette view type that supports the helpers.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; MyView = Marionette.ItemView.extend({\n  &lt;span class=\&quot;hljs-comment\&quot;&gt;// ...&lt;/span&gt;\n});\n\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MyView({\n  templateHelpers: {\n    doFoo: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{ &lt;span class=\&quot;hljs-comment\&quot;&gt;/* ... */&lt;/span&gt; }\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;accessing-data-within-the-helpers\&quot; class=\&quot;anchor\&quot; href=\&quot;#accessing-data-within-the-helpers\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Accessing Data Within The Helpers&lt;/h3&gt;&lt;p&gt;In order to access data from within the helper methods, you\nneed to prefix the data you need with &lt;code&gt;this&lt;/code&gt;. Doing that will\ngive you all of the methods and attributes of the serialized\ndata object, including the other helper methods.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;templateHelpers: {\n  something: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;Do stuff with \&quot;&lt;/span&gt; + &lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;.name + &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot; because it&#x27;s awesome.\&quot;&lt;/span&gt;;\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;&lt;a name=\&quot;object-or-function-as-templatehelpers\&quot; class=\&quot;anchor\&quot; href=\&quot;#object-or-function-as-templatehelpers\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Object Or Function As &lt;code&gt;templateHelpers&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;You can specify an object literal (as shown above), a reference\nto an object literal, or a function as the &lt;code&gt;templateHelpers&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;If you specify a function, the function will be invoked\nwith the current view instance as the context of the\nfunction. The function must return an object that can be\nmixed in to the data for the view.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;Backbone.Marionette.ItemView.extend({\n  templateHelpers: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; {\n      foo: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{ &lt;span class=\&quot;hljs-comment\&quot;&gt;/* ... */&lt;/span&gt; }\n    }\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&lt;a name=\&quot;change-which-template-is-rendered-for-a-view\&quot; class=\&quot;anchor\&quot; href=\&quot;#change-which-template-is-rendered-for-a-view\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Change Which Template Is Rendered For A View&lt;/h2&gt;&lt;p&gt;There may be some cases where you need to change the template that is\nused for a view, based on some simple logic such as the value of a\nspecific attribute in the view&amp;#39;s model. To do this, you can provide\na &lt;code&gt;getTemplate&lt;/code&gt; function on your views and use this to return the\ntemplate that you need.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyView = Backbone.Marionette.ItemView.extend({\n  getTemplate: &lt;span class=\&quot;hljs-function\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt;&lt;span class=\&quot;hljs-params\&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\&quot;hljs-keyword\&quot;&gt;if&lt;/span&gt; (&lt;span class=\&quot;hljs-keyword\&quot;&gt;this&lt;/span&gt;.model.get(&lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;foo\&quot;&lt;/span&gt;)){\n      &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;#some-template\&quot;&lt;/span&gt;;\n    } &lt;span class=\&quot;hljs-keyword\&quot;&gt;else&lt;/span&gt; {\n      &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;#a-different-template\&quot;&lt;/span&gt;;\n    }\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This applies to all view types.&lt;/p&gt;\n&quot;
}</pre>
        <h1><a name="marionette-view" class="anchor" href="#marionette-view"><span class="header-link"></span></a>Marionette.View</h1><p>Marionette has a base <code>Marionette.View</code> type that other views extend from.
This base view provides some common and core functionality for
other views to take advantage of.</p>
<p><strong>Note:</strong> The <code>Marionette.View</code> type is not intended to be
used directly. It exists as a base view for other view types
to be extended from, and to provide a common location for
behaviors that are shared across all views.</p>
<h2><a name="documentation-index" class="anchor" href="#documentation-index"><span class="header-link"></span></a>Documentation Index</h2><ul>
<li><a href="#binding-to-view-events">Binding To View Events</a></li>
<li><a href="#view-onshow">View onShow</a></li>
<li><a href="#view-close">View close</a></li>
<li><a href="#view-onbeforeclose">View onBeforeClose</a></li>
<li><a href="#view-domrefresh--ondomrefresh-event">View &quot;dom:refresh&quot; / onDomRefresh event</a></li>
<li><a href="#viewtriggers">View.triggers</a></li>
<li><a href="#viewevents">View.events</a></li>
<li><a href="#viewmodelevents-and-viewcollectionevents">View.modelEvents and View.collectionEvents</a></li>
<li><a href="#viewserializedata">View.serializeData</a></li>
<li><a href="#viewbinduielements">View.bindUIElements</a></li>
<li><a href="#viewtemplatehelpers">View.templateHelpers</a><ul>
<li><a href="#basic-example">Basic Example</a></li>
<li><a href="#accessing-data-within-the-helpers">Accessing Data Within The Helpers</a></li>
<li><a href="#object-or-function-as-templatehelpers">Object Or Function As <code>templateHelpers</code></a></li>
</ul>
</li>
<li><a href="#change-which-template-is-rendered-for-a-view">Change Which Template Is Rendered For A View</a></li>
</ul>
<h2><a name="binding-to-view-events" class="anchor" href="#binding-to-view-events"><span class="header-link"></span></a>Binding To View Events</h2><p>Marionette.View extends <code>Backbone.View</code>. It is recommended that you use
the <code>listenTo</code> method to bind model, collection, or other events from Backbone
and Marionette objects.</p>
<pre><code class="lang-js">MyView = Backbone.Marionette.ItemView.extend({
  initialize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">this</span>.listenTo(<span class="hljs-keyword">this</span>.model, <span class="hljs-string">"change:foo"</span>, <span class="hljs-keyword">this</span>.modelChanged);
    <span class="hljs-keyword">this</span>.listenTo(<span class="hljs-keyword">this</span>.collection, <span class="hljs-string">"add"</span>, <span class="hljs-keyword">this</span>.modelAdded);
  },

  modelChanged: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(model, value)</span></span>{
  },

  modelAdded: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(model)</span></span>{
  }
});
</code></pre>
<p>The context (<code>this</code>) will automatically be set to the view. You can
optionally set the context by using <code>_.bind</code>.</p>
<pre><code class="lang-js"><span class="hljs-comment">// Force the context of the "reconcileCollection" callback method to be the collection</span>
<span class="hljs-comment">// itself, for this event handler only (does not affect any other use of the</span>
<span class="hljs-comment">// "reconcileCollection" method)</span>
<span class="hljs-keyword">this</span>.listenTo(<span class="hljs-keyword">this</span>.collection, <span class="hljs-string">"add"</span>, _.bind(<span class="hljs-keyword">this</span>.reconcileCollection, <span class="hljs-keyword">this</span>.collection));
</code></pre>
<h2><a name="view-onshow" class="anchor" href="#view-onshow"><span class="header-link"></span></a>View onShow</h2><ul>
<li>&quot;show&quot; / <code>onShow</code> - Called on the view instance when the view has been rendered and displayed.</li>
</ul>
<p>This event can be used to react to when a view has been shown via a <a href="marionette.region.md">region</a>.
All <code>views</code> that inherit from the base <code>Marionette.View</code> class have this functionality. <code>ItemView</code>, &#39;CollectionView&#39;, &#39;CompositeView&#39;, &#39;Layout&#39;</p>
<pre><code class="lang-js">Backbone.Marionette.ItemView.extend({
  onShow: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// react to when a view has been shown</span>
  }
});
</code></pre>
<p>A common use case for the <code>onShow</code> method is to use it to add children views.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> LayoutView = Backbone.Marionette.Layout.extend({
   regions: {
     Header: <span class="hljs-string">'header'</span>,
     Section: <span class="hljs-string">'section'</span>
   },
   onShow: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">this</span>.Header.show(<span class="hljs-keyword">new</span> Header());
      <span class="hljs-keyword">this</span>.Section.show(<span class="hljs-keyword">new</span> Section());
   }
});
</code></pre>
<h2><a name="view-close" class="anchor" href="#view-close"><span class="header-link"></span></a>View close</h2><p>View implements a <code>close</code> method, which is called by the region
managers automatically. As part of the implementation, the following
are performed:</p>
<ul>
<li>call an <code>onBeforeClose</code> event on the view, if one is provided</li>
<li>call an <code>onClose</code> event on the view, if one is provided</li>
<li>unbind all custom view events</li>
<li>unbind all DOM events</li>
<li>remove <code>this.el</code> from the DOM</li>
<li>unbind all <code>listenTo</code> events</li>
</ul>
<p>By providing an <code>onClose</code> method in your view definition, you can
run custom code for your view that is fired after your view has been
closed and cleaned up. The <code>onClose</code> method will be passed any arguments
that <code>close</code> was invoked with. This lets you handle any additional clean
up code without having to override the <code>close</code> method.</p>
<pre><code class="lang-js">MyView = Backbone.Marionette.ItemView.extend({
  onClose: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1, arg2)</span></span>{
    <span class="hljs-comment">// custom cleanup or closing code, here</span>
  }
});

<span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> MyView();
v.close(arg1, arg2);
</code></pre>
<h2><a name="view-onbeforeclose" class="anchor" href="#view-onbeforeclose"><span class="header-link"></span></a>View onBeforeClose</h2><p>When closing a view, an <code>onBeforeClose</code> method will be called, if it
has been provided. It will be passed any arguments that <code>close</code> was
invoked with. If this method returns <code>false</code>, the view will not
be closed. Any other return value (including null or undefined) will
allow the view to be closed.</p>
<pre><code class="lang-js">MyView = Marionette.View.extend({

  onBeforeClose: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// prevent the view from being closed</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

});

<span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> MyView();

v.close(); <span class="hljs-comment">// view will remain open</span>
</code></pre>
<h3><a name="view-dom-refresh-ondomrefresh-event" class="anchor" href="#view-dom-refresh-ondomrefresh-event"><span class="header-link"></span></a>View &quot;dom:refresh&quot; / onDomRefresh event</h3><p>Triggered after the view has been rendered, has been shown in the DOM via a Marionette.Region, and has been
re-rendered.</p>
<p>This event / callback is useful for
<a href="http://lostechies.com/derickbailey/2012/02/20/using-jquery-plugins-and-ui-controls-with-backbone/">DOM-dependent UI plugins</a> such as
<a href="http://jqueryui.com/">jQueryUI</a> or <a href="http://kendoui.com">KendoUI</a>.</p>
<pre><code class="lang-js">Backbone.Marionette.ItemView.extend({
  onDomRefresh: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// manipulate the `el` here. it's already</span>
    <span class="hljs-comment">// been rendered, and is full of the view's</span>
    <span class="hljs-comment">// HTML, ready to go.</span>
  }
});
</code></pre>
<p>For more information about integration Marionette w/ KendoUI (also applicable to jQueryUI and other UI
widget suites), see <a href="http://www.kendoui.com/blogs/teamblog/posts/12-11-26/backbone_and_kendo_ui_a_beautiful_combination.aspx">this blog post on KendoUI + Backbone</a>.</p>
<h2><a name="view-events" class="anchor" href="#view-events"><span class="header-link"></span></a>View.events</h2><p>Since Views extend from backbone`s view class, you gain the benefits of the <a href="http://backbonejs.org/#View-delegateEvents">events hash</a>.</p>
<p>Some preprocessing sugar is added on top to add the ability to cross utilize the <code>ui</code> hash.</p>
<pre><code class="lang-js">MyView = Backbone.Marionette.ItemView.extend({
  <span class="hljs-comment">// ...</span>

  ui: {
    <span class="hljs-string">"cat"</span>: <span class="hljs-string">".dog"</span>
  },

  events: {
    <span class="hljs-string">"click @ui.cat"</span>: <span class="hljs-string">"bark"</span> <span class="hljs-comment">//is the same as "click .dog":</span>
  }
});
</code></pre>
<h2><a name="view-triggers" class="anchor" href="#view-triggers"><span class="header-link"></span></a>View.triggers</h2><p>Views can define a set of <code>triggers</code> as a hash, which will
convert a DOM event into a <code>view.triggerMethod</code> call.</p>
<p>The left side of the hash is a standard Backbone.View DOM
event configuration, while the right side of the hash is the
view event that you want to trigger from the view.</p>
<pre><code class="lang-js">MyView = Backbone.Marionette.ItemView.extend({
  <span class="hljs-comment">// ...</span>

  triggers: {
    <span class="hljs-string">"click .do-something"</span>: <span class="hljs-string">"something:do:it"</span>
  }
});

view = <span class="hljs-keyword">new</span> MyView();
view.render();

view.on(<span class="hljs-string">"something:do:it"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(args)</span></span>{
  alert(<span class="hljs-string">"I DID IT!"</span>);
});

<span class="hljs-comment">// "click" the 'do-something' DOM element to</span>
<span class="hljs-comment">// demonstrate the DOM event conversion</span>
view.$(<span class="hljs-string">".do-something"</span>).trigger(<span class="hljs-string">"click"</span>);
</code></pre>
<p>The result of this is an alert box that says, &quot;I DID IT!&quot;</p>
<p>By default all triggers are stopped with <code>preventDefault</code> and <code>stopPropagation</code> methods. But you can manually configure the triggers using hash instead of event name. Example below triggers an event and prevents default browser behaviour using <code>preventDefault</code> method.</p>
<pre><code class="lang-js">Backbone.Marionette.CompositeView.extend({
  triggers: {
    <span class="hljs-string">"click .do-something"</span>: {
      event: <span class="hljs-string">"something:do:it"</span>,
      preventDefault: <span class="hljs-literal">true</span>, <span class="hljs-comment">// this param is optional and will default to true</span>
      stopPropagation: <span class="hljs-literal">false</span>
    }
  }
});
</code></pre>
<p>You can also specify the <code>triggers</code> as a function that
returns a hash of trigger configurations</p>
<pre><code class="lang-js">Backbone.Marionette.CompositeView.extend({
  triggers: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-string">"click .that-thing"</span>: <span class="hljs-string">"that:i:sent:you"</span>
    };
  }
});
</code></pre>
<p>Trigger keys can be configured to cross utilize the <code>ui</code> hash.</p>
<pre><code class="lang-js">Backbone.Marionette.ItemView.extend({
  ui: {
     <span class="hljs-string">'monkey'</span>: <span class="hljs-string">'.guybrush'</span>
  },
  triggers: {
    <span class="hljs-string">'click @ui.monkey'</span>: <span class="hljs-string">'see:LeChuck'</span> <span class="hljs-comment">// equivalent of "click .guybrush"</span>
  }
});
</code></pre>
<p>Triggers work with all View types that extend from the base
Marionette.View.</p>
<h3><a name="trigger-handler-arguments" class="anchor" href="#trigger-handler-arguments"><span class="header-link"></span></a>Trigger Handler Arguments</h3><p>A <code>trigger</code> event handler will receive a single argument that
includes the following:</p>
<ul>
<li>view</li>
<li>model</li>
<li>collection</li>
</ul>
<p>These properties match the <code>view</code>, <code>model</code>, and <code>collection</code> properties of the view that triggered the event.</p>
<pre><code class="lang-js">MyView = Backbone.Marionette.ItemView.extend({
  <span class="hljs-comment">// ...</span>

  triggers: {
    <span class="hljs-string">"click .do-something"</span>: <span class="hljs-string">"some:event"</span>
  }
});

view = <span class="hljs-keyword">new</span> MyView();

view.on(<span class="hljs-string">"some:event"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(args)</span></span>{
  args.view; <span class="hljs-comment">// =&gt; the view instance that triggered the event</span>
  args.model; <span class="hljs-comment">// =&gt; the view.model, if one was set on the view</span>
  args.collection; <span class="hljs-comment">// =&gt; the view.collection, if one was set on the view</span>
});
</code></pre>
<p>Having access to these allows more flexibility in handling events from
multiple views. For example, a tab control or expand/collapse widget such
as a panel bar could trigger the same event from many different views
and be handled with a single function.</p>
<h2><a name="view-modelevents-and-view-collectionevents" class="anchor" href="#view-modelevents-and-view-collectionevents"><span class="header-link"></span></a>View.modelEvents and View.collectionEvents</h2><p>Similar to the <code>events</code> hash, views can specify a configuration
hash for collections and models. The left side is the event on
the model or collection, and the right side is the name of the
method on the view.</p>
<pre><code class="lang-js">Backbone.Marionette.CompositeView.extend({

  modelEvents: {
    <span class="hljs-string">"change:name"</span>: <span class="hljs-string">"nameChanged"</span> <span class="hljs-comment">// equivalent to view.listenTo(view.model, "change:name", view.nameChanged, view)</span>
  },

  collectionEvents: {
    <span class="hljs-string">"add"</span>: <span class="hljs-string">"itemAdded"</span> <span class="hljs-comment">// equivalent to view.listenTo(view.collection, "add", view.itemAdded, view)</span>
  },

  <span class="hljs-comment">// ... event handler methods</span>
  nameChanged: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{ <span class="hljs-comment">/* ... */</span> },
  itemAdded: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{ <span class="hljs-comment">/* ... */</span> },

})
</code></pre>
<p>These will use the memory safe <code>listenTo</code>, and will set the context
(the value of <code>this</code>) in the handler to be the view. Events are
bound at the time of instantiation, and an exception will be thrown
if the handlers on the view do not exist.</p>
<p>The <code>modelEvents</code> and <code>collectionEvents</code> will be bound and
unbound with the Backbone.View <code>delegateEvents</code> and <code>undelegateEvents</code>
method calls. This allows the view to be re-used and have
the model and collection events re-bound.</p>
<h3><a name="multiple-callbacks" class="anchor" href="#multiple-callbacks"><span class="header-link"></span></a>Multiple Callbacks</h3><p>Multiple callback functions can be specified by separating them with a
space.</p>
<pre><code class="lang-js">Backbone.Marionette.CompositeView.extend({

  modelEvents: {
    <span class="hljs-string">"change:name"</span>: <span class="hljs-string">"nameChanged thatThing"</span>
  },

  nameChanged: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{ },

  thatThing: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{ },
});
</code></pre>
<p>This works in both <code>modelEvents</code> and <code>collectionEvents</code>.</p>
<h3><a name="callbacks-as-function" class="anchor" href="#callbacks-as-function"><span class="header-link"></span></a>Callbacks As Function</h3><p>A single function can be declared directly in-line instead of specifying a
callback via a string method name.</p>
<pre><code class="lang-js">Backbone.Marionette.CompositeView.extend({

  modelEvents: {
    <span class="hljs-string">"change:name"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
      <span class="hljs-comment">// handle the name changed event here</span>
    }
  }

});
</code></pre>
<p>This works for both <code>modelEvents</code> and <code>collectionEvents</code>.</p>
<h3><a name="event-configuration-as-function" class="anchor" href="#event-configuration-as-function"><span class="header-link"></span></a>Event Configuration As Function</h3><p>A function can be used to declare the event configuration as long as
that function returns a hash that fits the above configuration options.</p>
<pre><code class="lang-js">Backbone.Marionette.CompositeView.extend({

  modelEvents: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">return</span> { <span class="hljs-string">"change:name"</span>: <span class="hljs-string">"someFunc"</span> };
  }

});
</code></pre>
<p>This works for both <code>modelEvents</code> and <code>collectionEvents</code>.</p>
<h2><a name="view-serializedata" class="anchor" href="#view-serializedata"><span class="header-link"></span></a>View.serializeData</h2><p>The <code>serializeData</code> method will serialize a view&#39;s model or
collection - with precedence given to collections. That is,
if you have both a collection and a model in a view, calling
the <code>serializeData</code> method will return the serialized
collection.</p>
<h2><a name="view-binduielements" class="anchor" href="#view-binduielements"><span class="header-link"></span></a>View.bindUIElements</h2><p>In several cases you need to access ui elements inside the view
to retrieve their data or manipulate them. For example you have a
certain div element you need to show/hide based on some state,
or other ui element that you wish to set a css class to it.
Instead of having jQuery selectors hanging around in the view&#39;s code
you can define a <code>ui</code> hash that contains a mapping between the
ui element&#39;s name and its jQuery selector. Afterwards you can simply
access it via <code>this.ui.elementName</code>.
See ItemView documentation for examples.</p>
<p>This functionality is provided via the <code>bindUIElements</code> method.
Since View doesn&#39;t implement the render method, then if you directly extend
from View you will need to invoke this method from your render method.
In ItemView and CompositeView this is already taken care of.</p>
<h2><a name="view-templatehelpers" class="anchor" href="#view-templatehelpers"><span class="header-link"></span></a>View.templateHelpers</h2><p>There are times when a view&#39;s template needs to have some
logic in it and the view engine itself will not provide an
easy way to accomplish this. For example, Underscore templates
do not provide a helper method mechanism while Handlebars
templates do.</p>
<p>A <code>templateHelpers</code> attribute can be applied to any View object that
renders a template. When this attribute is present its contents
will be mixed in to the data object that comes back from the
<code>serializeData</code> method. This will allow you to create helper methods
that can be called from within your templates.</p>
<h3><a name="basic-example" class="anchor" href="#basic-example"><span class="header-link"></span></a>Basic Example</h3><pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"my-template"</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/html"</span>&gt;</span><span class="javascript">
  I think that &lt;%= showMessage() %&gt;
</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<pre><code class="lang-js">MyView = Backbone.Marionette.ItemView.extend({
  template: <span class="hljs-string">"#my-template"</span>,

  templateHelpers: {
    showMessage: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name + <span class="hljs-string">" is the coolest!"</span>
    }
  }

});

model = <span class="hljs-keyword">new</span> Backbone.Model({name: <span class="hljs-string">"Backbone.Marionette"</span>});
view = <span class="hljs-keyword">new</span> MyView({
  model: model
});

view.render(); <span class="hljs-comment">//=&gt; "I think that Backbone.Marionette is the coolest!";</span>
</code></pre>
<p>The <code>templateHelpers</code> can also be provided as a constructor parameter
for any Marionette view type that supports the helpers.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> MyView = Marionette.ItemView.extend({
  <span class="hljs-comment">// ...</span>
});

<span class="hljs-keyword">new</span> MyView({
  templateHelpers: {
    doFoo: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{ <span class="hljs-comment">/* ... */</span> }
  }
});
</code></pre>
<h3><a name="accessing-data-within-the-helpers" class="anchor" href="#accessing-data-within-the-helpers"><span class="header-link"></span></a>Accessing Data Within The Helpers</h3><p>In order to access data from within the helper methods, you
need to prefix the data you need with <code>this</code>. Doing that will
give you all of the methods and attributes of the serialized
data object, including the other helper methods.</p>
<pre><code class="lang-js">templateHelpers: {
  something: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Do stuff with "</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">" because it's awesome."</span>;
  }
}
</code></pre>
<h3><a name="object-or-function-as-templatehelpers" class="anchor" href="#object-or-function-as-templatehelpers"><span class="header-link"></span></a>Object Or Function As <code>templateHelpers</code></h3><p>You can specify an object literal (as shown above), a reference
to an object literal, or a function as the <code>templateHelpers</code>.</p>
<p>If you specify a function, the function will be invoked
with the current view instance as the context of the
function. The function must return an object that can be
mixed in to the data for the view.</p>
<pre><code class="lang-js">Backbone.Marionette.ItemView.extend({
  templateHelpers: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">return</span> {
      foo: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{ <span class="hljs-comment">/* ... */</span> }
    }
  }
});
</code></pre>
<h2><a name="change-which-template-is-rendered-for-a-view" class="anchor" href="#change-which-template-is-rendered-for-a-view"><span class="header-link"></span></a>Change Which Template Is Rendered For A View</h2><p>There may be some cases where you need to change the template that is
used for a view, based on some simple logic such as the value of a
specific attribute in the view&#39;s model. To do this, you can provide
a <code>getTemplate</code> function on your views and use this to return the
template that you need.</p>
<pre><code class="lang-js">MyView = Backbone.Marionette.ItemView.extend({
  getTemplate: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.model.get(<span class="hljs-string">"foo"</span>)){
      <span class="hljs-keyword">return</span> <span class="hljs-string">"#some-template"</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"#a-different-template"</span>;
    }
  }
});
</code></pre>
<p>This applies to all view types.</p>

      </div>
    </div>
  </body>
</html>
