<html>
  <head>
    <title>marionette.layout - Marionette.js Docs</title>
    <link rel="stylesheet" href="../../styles/main.css">
  </head>
  <body>
    <div class="docs">
      <div class="docs__sidebar">
        <select>
          
            <option value="v0.1.0">v0.1.0</option>
          
            <option value="v0.10.0">v0.10.0</option>
          
            <option value="v0.10.1">v0.10.1</option>
          
            <option value="v0.10.2">v0.10.2</option>
          
            <option value="v0.2.0">v0.2.0</option>
          
            <option value="v0.2.1">v0.2.1</option>
          
            <option value="v0.2.2">v0.2.2</option>
          
            <option value="v0.2.3">v0.2.3</option>
          
            <option value="v0.2.4">v0.2.4</option>
          
            <option value="v0.2.5">v0.2.5</option>
          
            <option value="v0.2.6">v0.2.6</option>
          
            <option value="v0.3.0">v0.3.0</option>
          
            <option value="v0.3.1">v0.3.1</option>
          
            <option value="v0.4.0">v0.4.0</option>
          
            <option value="v0.4.1">v0.4.1</option>
          
            <option value="v0.4.1a">v0.4.1a</option>
          
            <option value="v0.4.2">v0.4.2</option>
          
            <option value="v0.4.3">v0.4.3</option>
          
            <option value="v0.4.4">v0.4.4</option>
          
            <option value="v0.4.5">v0.4.5</option>
          
            <option value="v0.4.6">v0.4.6</option>
          
            <option value="v0.4.7">v0.4.7</option>
          
            <option value="v0.4.8">v0.4.8</option>
          
            <option value="v0.5.0">v0.5.0</option>
          
            <option value="v0.5.1">v0.5.1</option>
          
            <option value="v0.5.2">v0.5.2</option>
          
            <option value="v0.6.0">v0.6.0</option>
          
            <option value="v0.6.1">v0.6.1</option>
          
            <option value="v0.6.2">v0.6.2</option>
          
            <option value="v0.6.3">v0.6.3</option>
          
            <option value="v0.7.0">v0.7.0</option>
          
            <option value="v0.7.1">v0.7.1</option>
          
            <option value="v0.7.2">v0.7.2</option>
          
            <option value="v0.7.3">v0.7.3</option>
          
            <option value="v0.7.4">v0.7.4</option>
          
            <option value="v0.7.5">v0.7.5</option>
          
            <option value="v0.7.6">v0.7.6</option>
          
            <option value="v0.8.0">v0.8.0</option>
          
            <option value="v0.8.1">v0.8.1</option>
          
            <option value="v0.8.2">v0.8.2</option>
          
            <option value="v0.8.3">v0.8.3</option>
          
            <option value="v0.8.4">v0.8.4</option>
          
            <option value="v0.9.0">v0.9.0</option>
          
            <option value="v0.9.1">v0.9.1</option>
          
            <option value="v0.9.10">v0.9.10</option>
          
            <option value="v0.9.11">v0.9.11</option>
          
            <option value="v0.9.12">v0.9.12</option>
          
            <option value="v0.9.13">v0.9.13</option>
          
            <option value="v0.9.2">v0.9.2</option>
          
            <option value="v0.9.3">v0.9.3</option>
          
            <option value="v0.9.4">v0.9.4</option>
          
            <option value="v0.9.5">v0.9.5</option>
          
            <option value="v0.9.6">v0.9.6</option>
          
            <option value="v0.9.7">v0.9.7</option>
          
            <option value="v0.9.8">v0.9.8</option>
          
            <option value="v0.9.9">v0.9.9</option>
          
            <option value="v1.0.0">v1.0.0</option>
          
            <option value="v1.0.0-beta1">v1.0.0-beta1</option>
          
            <option value="v1.0.0-beta2">v1.0.0-beta2</option>
          
            <option value="v1.0.0-beta3">v1.0.0-beta3</option>
          
            <option value="v1.0.0-beta4">v1.0.0-beta4</option>
          
            <option value="v1.0.0-beta5">v1.0.0-beta5</option>
          
            <option value="v1.0.0-beta6">v1.0.0-beta6</option>
          
            <option value="v1.0.0-rc1">v1.0.0-rc1</option>
          
            <option value="v1.0.0-rc2">v1.0.0-rc2</option>
          
            <option value="v1.0.0-rc3">v1.0.0-rc3</option>
          
            <option value="v1.0.0-rc4">v1.0.0-rc4</option>
          
            <option value="v1.0.0-rc5">v1.0.0-rc5</option>
          
            <option value="v1.0.0-rc6">v1.0.0-rc6</option>
          
            <option value="v1.0.1">v1.0.1</option>
          
            <option value="v1.0.2">v1.0.2</option>
          
            <option value="v1.0.3">v1.0.3</option>
          
            <option value="v1.0.4">v1.0.4</option>
          
            <option value="v1.1.0">v1.1.0</option>
          
            <option value="v1.2.0">v1.2.0</option>
          
            <option value="v1.2.1">v1.2.1</option>
          
            <option value="v1.2.2">v1.2.2</option>
          
            <option value="v1.2.3">v1.2.3</option>
          
            <option value="v1.3.0">v1.3.0</option>
          
            <option value="v1.4.0">v1.4.0</option>
          
            <option value="v1.4.0beta">v1.4.0beta</option>
          
            <option value="v1.4.1">v1.4.1</option>
          
            <option value="v1.5.0">v1.5.0</option>
          
            <option value="v1.5.1">v1.5.1</option>
          
            <option value="v1.6.0">v1.6.0</option>
          
            <option value="v1.6.1">v1.6.1</option>
          
            <option value="v1.6.2">v1.6.2</option>
          
            <option value="v1.6.3">v1.6.3</option>
          
            <option value="v1.6.4">v1.6.4</option>
          
            <option value="v1.7">v1.7</option>
          
            <option value="v1.7.1">v1.7.1</option>
          
            <option value="v1.7.2">v1.7.2</option>
          
            <option value="v1.7.3">v1.7.3</option>
          
            <option value="v1.7.4">v1.7.4</option>
          
            <option value="v1.8.0">v1.8.0</option>
          
            <option value="v1.8.1">v1.8.1</option>
          
            <option value="v1.8.2">v1.8.2</option>
          
            <option value="v1.8.3">v1.8.3</option>
          
            <option value="v1.8.4">v1.8.4</option>
          
            <option value="v1.8.5">v1.8.5</option>
          
            <option value="v1.8.6">v1.8.6</option>
          
            <option value="v1.8.7">v1.8.7</option>
          
            <option value="v1.8.8">v1.8.8</option>
          
            <option value="v2.0.0">v2.0.0</option>
          
            <option value="v2.0.0-pre.1">v2.0.0-pre.1</option>
          
            <option value="v2.0.0-pre.2">v2.0.0-pre.2</option>
          
            <option value="v2.0.1">v2.0.1</option>
          
            <option value="v2.0.2">v2.0.2</option>
          
            <option value="v2.0.3">v2.0.3</option>
          
            <option value="v2.1.0">v2.1.0</option>
          
            <option value="v2.1.0-pre">v2.1.0-pre</option>
          
            <option value="v2.2.0">v2.2.0</option>
          
            <option value="v2.2.0-pre">v2.2.0-pre</option>
          
            <option value="v2.2.0-pre.2">v2.2.0-pre.2</option>
          
            <option value="v2.2.1">v2.2.1</option>
          
        </select>
        <nav>
          
            <a href="marionette.application.html">marionette.application</a>
          
            <a href="marionette.application.module.html">marionette.application.module</a>
          
            <a href="marionette.approuter.html">marionette.approuter</a>
          
            <a href="marionette.async.html">marionette.async</a>
          
            <a href="marionette.callbacks.html">marionette.callbacks</a>
          
            <a href="marionette.collectionview.html">marionette.collectionview</a>
          
            <a href="marionette.compositeview.html">marionette.compositeview</a>
          
            <a href="marionette.eventaggregator.html">marionette.eventaggregator</a>
          
            <a href="marionette.eventbinder.html">marionette.eventbinder</a>
          
            <a href="marionette.itemview.html">marionette.itemview</a>
          
            <a href="marionette.layout.html">marionette.layout</a>
          
            <a href="marionette.region.html">marionette.region</a>
          
            <a href="marionette.renderer.html">marionette.renderer</a>
          
            <a href="marionette.templatecache.html">marionette.templatecache</a>
          
            <a href="marionette.view.html">marionette.view</a>
          
        </nav>
      </div>
      <div class="docs__content">
        <pre>{
  &quot;tag&quot;: &quot;v0.9.8&quot;,
  &quot;basename&quot;: &quot;marionette.layout&quot;,
  &quot;filenane&quot;: &quot;marionette.layout.md&quot;,
  &quot;pathname&quot;: &quot;/Users/sam/Desktop/repos/marionettejs.com/.grunt/compileDocs/1412653309300/v0.9.8&quot;,
  &quot;contents&quot;: &quot;&lt;h1&gt;&lt;a name=\&quot;marionette-layout\&quot; class=\&quot;anchor\&quot; href=\&quot;#marionette-layout\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Marionette.Layout&lt;/h1&gt;&lt;p&gt;A &lt;code&gt;Layout&lt;/code&gt; is a specialized hybrid between an &lt;code&gt;ItemView&lt;/code&gt; and\na collection of &lt;code&gt;Region&lt;/code&gt; objects, used for rendering an application\nlayout with multiple sub-regions to be managed by specified region managers.&lt;/p&gt;\n&lt;p&gt;A layout manager can also be used as a composite-view to aggregate multiple\nviews and sub-application areas of the screen where multiple region managers need\nto be attached to dynamically rendered HTML.&lt;/p&gt;\n&lt;p&gt;For a more in-depth discussion on Layouts, see the blog post\n&lt;a href=\&quot;http://lostechies.com/derickbailey/2012/03/22/managing-layouts-and-nested-views-with-backbone-marionette/\&quot;&gt;Manage Layouts And Nested Views With Backbone.Marionette&lt;/a&gt;&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;basic-usage\&quot; class=\&quot;anchor\&quot; href=\&quot;#basic-usage\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Basic Usage&lt;/h2&gt;&lt;p&gt;The &lt;code&gt;Layout&lt;/code&gt; extends directly from &lt;code&gt;ItemView&lt;/code&gt; and adds the ability\nto specify &lt;code&gt;regions&lt;/code&gt; which become &lt;code&gt;Region&lt;/code&gt; instances that are attached\nto the layout.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-html\&quot;&gt;&lt;span class=\&quot;hljs-tag\&quot;&gt;&amp;lt;&lt;span class=\&quot;hljs-title\&quot;&gt;script&lt;/span&gt; &lt;span class=\&quot;hljs-attribute\&quot;&gt;id&lt;/span&gt;=&lt;span class=\&quot;hljs-value\&quot;&gt;\&quot;layout-template\&quot;&lt;/span&gt; &lt;span class=\&quot;hljs-attribute\&quot;&gt;type&lt;/span&gt;=&lt;span class=\&quot;hljs-value\&quot;&gt;\&quot;text/template\&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=\&quot;javascript\&quot;&gt;\n  &amp;lt;section&amp;gt;\n    &lt;span class=\&quot;xml\&quot;&gt;&lt;span class=\&quot;hljs-tag\&quot;&gt;&amp;lt;&lt;span class=\&quot;hljs-title\&quot;&gt;navigation&lt;/span&gt; &lt;span class=\&quot;hljs-attribute\&quot;&gt;id&lt;/span&gt;=&lt;span class=\&quot;hljs-value\&quot;&gt;\&quot;menu\&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;...&lt;span class=\&quot;hljs-tag\&quot;&gt;&amp;lt;/&lt;span class=\&quot;hljs-title\&quot;&gt;navigation&lt;/span&gt;&amp;gt;&lt;/span&gt;\n    &lt;span class=\&quot;hljs-tag\&quot;&gt;&amp;lt;&lt;span class=\&quot;hljs-title\&quot;&gt;article&lt;/span&gt; &lt;span class=\&quot;hljs-attribute\&quot;&gt;id&lt;/span&gt;=&lt;span class=\&quot;hljs-value\&quot;&gt;\&quot;content\&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;...&lt;span class=\&quot;hljs-tag\&quot;&gt;&amp;lt;/&lt;span class=\&quot;hljs-title\&quot;&gt;article&lt;/span&gt;&amp;gt;&lt;/span&gt;\n  &lt;span class=\&quot;hljs-tag\&quot;&gt;&amp;lt;/&lt;span class=\&quot;hljs-title\&quot;&gt;section&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;/span&gt;&lt;/span&gt;&lt;span class=\&quot;hljs-tag\&quot;&gt;&amp;lt;/&lt;span class=\&quot;hljs-title\&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;AppLayout = Backbone.Marionette.Layout.extend({\n  template: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;#layout-template\&quot;&lt;/span&gt;,\n\n  regions: {\n    menu: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;#menu\&quot;&lt;/span&gt;,\n    content: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;#content\&quot;&lt;/span&gt;\n  }\n});\n\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; layout = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; AppLayout();\nlayout.render();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Once you&amp;#39;ve rendered the layout, you now have direct access\nto all of the specified regions as region managers.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;layout.menu.show(&lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MenuView());\n\nlayout.content.show(&lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MainContentView());\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&lt;a name=\&quot;region-availability\&quot; class=\&quot;anchor\&quot; href=\&quot;#region-availability\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Region Availability&lt;/h2&gt;&lt;p&gt;Any defined regions within a layout will be available to the\nlayout or any calling code immediately after instantiating the\nlayout. This allows a layout to be attached to an existing \nDOM element in an HTML page, without the need to call a render\nmethod or anything else, to create the regions.&lt;/p&gt;\n&lt;p&gt;However, a region will only be able to populate itself if the\nlayout has access to the elements specified within the region\ndefinitions. That is, if your view has not yet rendered, your\nregions may not be able to find the element that you&amp;#39;ve\nspecified for them to manage. In that scenario, using the\nregion will result in no changes to the DOM.&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;re-rendering-a-layout\&quot; class=\&quot;anchor\&quot; href=\&quot;#re-rendering-a-layout\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Re-Rendering A Layout&lt;/h2&gt;&lt;p&gt;A layout can be rendered as many times as needed, but renders\nafter the first one behave differently than the initial render.&lt;/p&gt;\n&lt;p&gt;The first time a layout is rendered, nothing special happens. It just\ndelegates to the &lt;code&gt;ItemView&lt;/code&gt; prototype to do the render. After the\nfirst render has happened, though, the render function is modified to\naccount for re-rendering with regions in the layout.&lt;/p&gt;\n&lt;p&gt;After the first render, all subsequent renders will force every\nregion to close by calling the &lt;code&gt;close&lt;/code&gt; method on them. This will\nforce every view in the region, and sub-views if any, to be closed\nas well. Once the regions have been closed, the regions will be\nreset so that they are no longer referencing the element of the previous\nlayout render. &lt;/p&gt;\n&lt;p&gt;Then after the Layout is finished re-rendering itself,\nshowing a view in the layout&amp;#39;s regions will cause the regions to attach\nthemselves to the new elements in the layout.&lt;/p&gt;\n&lt;h3&gt;&lt;a name=\&quot;avoid-re-rendering-the-entire-layout\&quot; class=\&quot;anchor\&quot; href=\&quot;#avoid-re-rendering-the-entire-layout\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Avoid Re-Rendering The Entire Layout&lt;/h3&gt;&lt;p&gt;There are times when re-rendering the entire layout is necessary. However,\ndue to the behavior described above, this can cause a large amount of\nwork to be needed in order to fully restore the layout and all of the\nviews that the layout is displaying.&lt;/p&gt;\n&lt;p&gt;Therefore, it is suggested that you avoid re-rendering the entire\nlayout unless absolutely necessary. Instead, if you are binding the\nlayout&amp;#39;s template to a model and need to update portions of the layout,\nyou should listen to the model&amp;#39;s &amp;quot;change&amp;quot; events and only update the\nneccesary DOM elements.&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;nested-layouts-and-views\&quot; class=\&quot;anchor\&quot; href=\&quot;#nested-layouts-and-views\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Nested Layouts And Views&lt;/h2&gt;&lt;p&gt;Since the &lt;code&gt;Layout&lt;/code&gt; extends directly from &lt;code&gt;ItemView&lt;/code&gt;, it\nhas all of the core functionality of an item view. This includes\nthe methods necessary to be shown within an existing region manager.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyApp = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; Backbone.Marionette.Application();\nMyApp.addRegions({\n  mainRegion: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;#main\&quot;&lt;/span&gt;\n});\n\n&lt;span class=\&quot;hljs-keyword\&quot;&gt;var&lt;/span&gt; layout = &lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; AppLayout();\nMyApp.mainRegion.show(layout);\n\nlayout.show(&lt;span class=\&quot;hljs-keyword\&quot;&gt;new&lt;/span&gt; MenuView());\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You can nest layouts into region managers as deeply as you want.\nThis provides for a well organized, nested view structure.&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;closing-a-layout\&quot; class=\&quot;anchor\&quot; href=\&quot;#closing-a-layout\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Closing A Layout&lt;/h2&gt;&lt;p&gt;When you are finished with a layout, you can call the\n&lt;code&gt;close&lt;/code&gt; method on it. This will ensure that all of the region managers\nwithin the layout are closed correctly, which in turn\nensures all of the views shown within the regions are closed correctly.&lt;/p&gt;\n&lt;p&gt;If you are showing a layout within a parent region manager, replacing \nthe layout with another view or another layout will close the current \none, the same it will close a view.&lt;/p&gt;\n&lt;p&gt;All of this ensures that layouts and the views that they\ncontain are cleaned up correctly.&lt;/p&gt;\n&lt;h2&gt;&lt;a name=\&quot;custom-region-type\&quot; class=\&quot;anchor\&quot; href=\&quot;#custom-region-type\&quot;&gt;&lt;span class=\&quot;header-link\&quot;&gt;&lt;/span&gt;&lt;/a&gt;Custom Region Type&lt;/h2&gt;&lt;p&gt;If you have the need to replace the &lt;code&gt;Region&lt;/code&gt; with a region class of\nyour own implementation, you can specify an alternate class to use\nwith the &lt;code&gt;regionType&lt;/code&gt; propery of the &lt;code&gt;Layout&lt;/code&gt;.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;MyLayout = Backbone.Marionette.Layout.extend({\n  regionType: SomeCustomRegion \n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You can also specify custom &lt;code&gt;Region&lt;/code&gt; classes for each &lt;code&gt;region&lt;/code&gt;:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;lang-js\&quot;&gt;AppLayout = Backbone.Marionette.Layout.extend({\n  template: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;#layout-template\&quot;&lt;/span&gt;,\n\n  regionType: SomeDefaultCustomRegion,\n\n  regions: {\n    menu: {\n      selector: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;#menu\&quot;&lt;/span&gt;,\n      regionType: CustomRegionTypeReference\n    },\n    content: {\n      selector: &lt;span class=\&quot;hljs-string\&quot;&gt;\&quot;#content\&quot;&lt;/span&gt;,\n      regionType: CustomRegionType2Reference\n    }\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&quot;
}</pre>
        <h1><a name="marionette-layout" class="anchor" href="#marionette-layout"><span class="header-link"></span></a>Marionette.Layout</h1><p>A <code>Layout</code> is a specialized hybrid between an <code>ItemView</code> and
a collection of <code>Region</code> objects, used for rendering an application
layout with multiple sub-regions to be managed by specified region managers.</p>
<p>A layout manager can also be used as a composite-view to aggregate multiple
views and sub-application areas of the screen where multiple region managers need
to be attached to dynamically rendered HTML.</p>
<p>For a more in-depth discussion on Layouts, see the blog post
<a href="http://lostechies.com/derickbailey/2012/03/22/managing-layouts-and-nested-views-with-backbone-marionette/">Manage Layouts And Nested Views With Backbone.Marionette</a></p>
<h2><a name="basic-usage" class="anchor" href="#basic-usage"><span class="header-link"></span></a>Basic Usage</h2><p>The <code>Layout</code> extends directly from <code>ItemView</code> and adds the ability
to specify <code>regions</code> which become <code>Region</code> instances that are attached
to the layout.</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"layout-template"</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/template"</span>&gt;</span><span class="javascript">
  &lt;section&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">navigation</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"menu"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-title">navigation</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">article</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"content"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-title">article</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">section</span>&gt;</span>
</span></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<pre><code class="lang-js">AppLayout = Backbone.Marionette.Layout.extend({
  template: <span class="hljs-string">"#layout-template"</span>,

  regions: {
    menu: <span class="hljs-string">"#menu"</span>,
    content: <span class="hljs-string">"#content"</span>
  }
});

<span class="hljs-keyword">var</span> layout = <span class="hljs-keyword">new</span> AppLayout();
layout.render();
</code></pre>
<p>Once you&#39;ve rendered the layout, you now have direct access
to all of the specified regions as region managers.</p>
<pre><code class="lang-js">layout.menu.show(<span class="hljs-keyword">new</span> MenuView());

layout.content.show(<span class="hljs-keyword">new</span> MainContentView());
</code></pre>
<h2><a name="region-availability" class="anchor" href="#region-availability"><span class="header-link"></span></a>Region Availability</h2><p>Any defined regions within a layout will be available to the
layout or any calling code immediately after instantiating the
layout. This allows a layout to be attached to an existing 
DOM element in an HTML page, without the need to call a render
method or anything else, to create the regions.</p>
<p>However, a region will only be able to populate itself if the
layout has access to the elements specified within the region
definitions. That is, if your view has not yet rendered, your
regions may not be able to find the element that you&#39;ve
specified for them to manage. In that scenario, using the
region will result in no changes to the DOM.</p>
<h2><a name="re-rendering-a-layout" class="anchor" href="#re-rendering-a-layout"><span class="header-link"></span></a>Re-Rendering A Layout</h2><p>A layout can be rendered as many times as needed, but renders
after the first one behave differently than the initial render.</p>
<p>The first time a layout is rendered, nothing special happens. It just
delegates to the <code>ItemView</code> prototype to do the render. After the
first render has happened, though, the render function is modified to
account for re-rendering with regions in the layout.</p>
<p>After the first render, all subsequent renders will force every
region to close by calling the <code>close</code> method on them. This will
force every view in the region, and sub-views if any, to be closed
as well. Once the regions have been closed, the regions will be
reset so that they are no longer referencing the element of the previous
layout render. </p>
<p>Then after the Layout is finished re-rendering itself,
showing a view in the layout&#39;s regions will cause the regions to attach
themselves to the new elements in the layout.</p>
<h3><a name="avoid-re-rendering-the-entire-layout" class="anchor" href="#avoid-re-rendering-the-entire-layout"><span class="header-link"></span></a>Avoid Re-Rendering The Entire Layout</h3><p>There are times when re-rendering the entire layout is necessary. However,
due to the behavior described above, this can cause a large amount of
work to be needed in order to fully restore the layout and all of the
views that the layout is displaying.</p>
<p>Therefore, it is suggested that you avoid re-rendering the entire
layout unless absolutely necessary. Instead, if you are binding the
layout&#39;s template to a model and need to update portions of the layout,
you should listen to the model&#39;s &quot;change&quot; events and only update the
neccesary DOM elements.</p>
<h2><a name="nested-layouts-and-views" class="anchor" href="#nested-layouts-and-views"><span class="header-link"></span></a>Nested Layouts And Views</h2><p>Since the <code>Layout</code> extends directly from <code>ItemView</code>, it
has all of the core functionality of an item view. This includes
the methods necessary to be shown within an existing region manager.</p>
<pre><code class="lang-js">MyApp = <span class="hljs-keyword">new</span> Backbone.Marionette.Application();
MyApp.addRegions({
  mainRegion: <span class="hljs-string">"#main"</span>
});

<span class="hljs-keyword">var</span> layout = <span class="hljs-keyword">new</span> AppLayout();
MyApp.mainRegion.show(layout);

layout.show(<span class="hljs-keyword">new</span> MenuView());
</code></pre>
<p>You can nest layouts into region managers as deeply as you want.
This provides for a well organized, nested view structure.</p>
<h2><a name="closing-a-layout" class="anchor" href="#closing-a-layout"><span class="header-link"></span></a>Closing A Layout</h2><p>When you are finished with a layout, you can call the
<code>close</code> method on it. This will ensure that all of the region managers
within the layout are closed correctly, which in turn
ensures all of the views shown within the regions are closed correctly.</p>
<p>If you are showing a layout within a parent region manager, replacing 
the layout with another view or another layout will close the current 
one, the same it will close a view.</p>
<p>All of this ensures that layouts and the views that they
contain are cleaned up correctly.</p>
<h2><a name="custom-region-type" class="anchor" href="#custom-region-type"><span class="header-link"></span></a>Custom Region Type</h2><p>If you have the need to replace the <code>Region</code> with a region class of
your own implementation, you can specify an alternate class to use
with the <code>regionType</code> propery of the <code>Layout</code>.</p>
<pre><code class="lang-js">MyLayout = Backbone.Marionette.Layout.extend({
  regionType: SomeCustomRegion 
});
</code></pre>
<p>You can also specify custom <code>Region</code> classes for each <code>region</code>:</p>
<pre><code class="lang-js">AppLayout = Backbone.Marionette.Layout.extend({
  template: <span class="hljs-string">"#layout-template"</span>,

  regionType: SomeDefaultCustomRegion,

  regions: {
    menu: {
      selector: <span class="hljs-string">"#menu"</span>,
      regionType: CustomRegionTypeReference
    },
    content: {
      selector: <span class="hljs-string">"#content"</span>,
      regionType: CustomRegionType2Reference
    }
  }
});
</code></pre>

      </div>
    </div>
  </body>
</html>
